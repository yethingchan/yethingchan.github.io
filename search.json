[{"title":"10月 - 每日反省","url":"/posts/2662318435.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><ul>\n<li>记录10月每日收获</li>\n</ul>\n<span id=\"more\"></span>\n<h1 id=\"26日\"><a href=\"#26日\" class=\"headerlink\" title=\"26日\"></a>26日</h1><hr>\n<p>学习了行列式的性质，五个字<strong>转换加乘拆</strong>，即转置、变换、倍加、数乘和拆分</p>\n<ul>\n<li>转置：行变成列，①行变成①列，n行变成n列…；并且转置之后等于原行列式</li>\n<li>变换：行列式的两行或者两列相互交换位置，整个行列式要变号；变换一次要变一次号</li>\n<li>倍加：某一行（列）的k倍之后加到另外一行（列）上，行列式值不变</li>\n<li>数乘：某一行或者某一列乘以一个数字相当于<strong>整个行列式</strong>乘以这个数</li>\n<li>拆分：针对行列式中加减的情况，一行（列）进行拆分，但是其余行（列）不变；<strong>一行（列）拆开，其余行（列）不变</strong><blockquote>\n<p>其中：<br>1：如果两行或者两列相同，则行列式值为0<br>2：数乘可以用来提炼某一行（列）的公因子实现化简行列式<br>3：一行（列）对应位置元素是另外一行（列）的倍数，则行列式值=0<br>4：倍加用来<strong>造0</strong>化简</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"27日\"><a href=\"#27日\" class=\"headerlink\" title=\"27日\"></a>27日</h1><hr>\n<p>  今天学习了行列式的按行展开和按列展开、余子式和代数余子式。主要利用一行或者一列中含0量高的那行（列），无论是二阶还是三阶都可以用行列式的展开来快速求解，相比于之前的使用行列式的性质（转换加倍分）来的快，但是这一块因为老师上课不好演示，学起来比较困难。</p>\n<p>  上午做行列式性质的时候，遇到一种有特点的题，就是无论哪一行，那一行所有元素加起来的和都是相同的，此题型的解题方法为：将第一列后面的几列全部加到第一列，然后第一列所有的元素都是相同的和，然后将这个和提到行列式的外面，然后第一列全都是1，此时再用行列式性质进行<strong>造0</strong>求解。</p>\n<h1 id=\"28日\"><a href=\"#28日\" class=\"headerlink\" title=\"28日\"></a>28日</h1><hr>\n<p>  上午开论文会，下午写论文写到回宿舍，回宿舍之后又帮其他宿舍的两个同学的代码搞了一下，搞到凌晨才回去。所以，收获几乎为0。</p>\n<h1 id=\"29日\"><a href=\"#29日\" class=\"headerlink\" title=\"29日\"></a>29日</h1><hr>\n<p>  今天白天一直都在做数学，晚上来把论文赶出来。<br>  数学学了行列式的按行展开按列展开的逆用，自己补充了异乘变零定理：一行（列）和另一行（列）的代数余子式相乘的和为0。此外还学了矩阵：概念，加减乘，一些特殊矩阵（单位矩阵、上三角矩阵、下三角…);<br>  计算四阶行列式步骤多，而且对不同的行或列进行造0很容易导致结果不同，这个地方需要自己大量练习计算。<br>  还有两天，数学继续干。</p>\n<h1 id=\"30日\"><a href=\"#30日\" class=\"headerlink\" title=\"30日\"></a>30日</h1><hr>\n<p>  今天上午在完善论文，一直在画E-R图，下午写论文，晚上改论文，单词背了四五百，其他无。属于是白忙活的一天。</p>\n","categories":["反省","10月"],"tags":["标签"]},{"title":"Favorite Songs","url":"/posts/4206195319.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"记录一些自己喜欢的歌，但是因为使用的音乐平台众多，所以想直接把名字写下来-回到小时候\"><a href=\"#记录一些自己喜欢的歌，但是因为使用的音乐平台众多，所以想直接把名字写下来-回到小时候\" class=\"headerlink\" title=\"记录一些自己喜欢的歌，但是因为使用的音乐平台众多，所以想直接把名字写下来### 回到小时候\"></a>记录一些自己喜欢的歌，但是因为使用的音乐平台众多，所以想直接把名字写下来<br><span id=\"more\"></span><br>### 回到小时候</h2><h3 id=\"回到初中的时候\"><a href=\"#回到初中的时候\" class=\"headerlink\" title=\"回到初中的时候\"></a>回到初中的时候</h3><hr>\n<h3 id=\"世纪初的感觉\"><a href=\"#世纪初的感觉\" class=\"headerlink\" title=\"世纪初的感觉\"></a>世纪初的感觉</h3><hr>\n<ol>\n<li>掉了 - 张惠妹</li>\n<li>最熟悉的人 - 萧亚轩</li>\n</ol>\n","categories":["爱好"],"tags":["爱好","音乐"]},{"title":"Plans for 2024","url":"/posts/2479467106.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>2024年升级清单</p>\n<span id=\"more\"></span>\n\n<p><strong>10月</strong></p>\n<ol>\n<li>数学基础班学完</li>\n<li>英语单词6000词重新过2轮</li>\n</ol>\n<hr>\n<p><strong>11月</strong></p>\n<ol>\n<li>数学所有课程做一遍</li>\n<li>英语套卷做30套，作文每种模板背十篇，听力把全国所有的听力过一轮</li>\n<li>专业课的PDF全部看完并熟知，时间充裕就做文字输出</li>\n<li>月末总结出自身的学习体系（流程 + 方法 + 细节）</li>\n</ol>\n<hr>\n<p><strong>12月</strong></p>\n<ul>\n<li>待定</li>\n</ul>\n","categories":["年度"],"tags":["年度期待","Planning"]},{"title":"Hexo使用手册","url":"/posts/1899991772.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><img src=\"/images/file-20241023124012083.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Hexo搭建教程\"><a href=\"#Hexo搭建教程\" class=\"headerlink\" title=\"Hexo搭建教程\"></a>Hexo搭建教程</h1><h5 id=\"知乎教程\"><a href=\"#知乎教程\" class=\"headerlink\" title=\"知乎教程\"></a><a href=\"https://zhuanlan.zhihu.com/p/60578464\">知乎教程</a></h5><h5 id=\"夜星梦尘\"><a href=\"#夜星梦尘\" class=\"headerlink\" title=\"夜星梦尘\"></a><a href=\"https://tech.yemengstar.com/hexo-tutorial-deploy-githubpages-beginner/\">夜星梦尘</a></h5><h5 id=\"CSDN个性化搭建\"><a href=\"#CSDN个性化搭建\" class=\"headerlink\" title=\"CSDN个性化搭建\"></a><a href=\"https://blog.csdn.net/as480133937/article/details/100138838\">CSDN个性化搭建</a></h5><hr>\n<h1 id=\"Hexo文档\"><a href=\"#Hexo文档\" class=\"headerlink\" title=\"Hexo文档\"></a>Hexo文档</h1><h3 id=\"Hexo中文文档\"><a href=\"#Hexo中文文档\" class=\"headerlink\" title=\"Hexo中文文档\"></a><strong><a href=\"https://hexo.io/zh-cn/docs/\">Hexo中文文档</a></strong></h3><h3 id=\"STUM文档\"><a href=\"#STUM文档\" class=\"headerlink\" title=\"STUM文档\"></a><a href=\"https://theme-stun.github.io/docs/zh-CN/guide/primary.html#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95\">STUM文档</a></h3><hr>\n<h1 id=\"Formatter介绍\"><a href=\"#Formatter介绍\" class=\"headerlink\" title=\"Formatter介绍\"></a>Formatter介绍</h1><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n<th>是否必需</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>页面标题</td>\n<td>是</td>\n<td>-</td>\n</tr>\n<tr>\n<td>date</td>\n<td>页面创建日期</td>\n<td>是</td>\n<td>-</td>\n</tr>\n<tr>\n<td>type</td>\n<td>标签、分类和友情链接三个页面需要配置</td>\n<td>是</td>\n<td>-</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>页面更新日期</td>\n<td>否</td>\n<td>-</td>\n</tr>\n<tr>\n<td>description</td>\n<td>页面描述</td>\n<td>否</td>\n<td>-</td>\n</tr>\n<tr>\n<td>keywords</td>\n<td>页面关键字</td>\n<td>否</td>\n<td>-</td>\n</tr>\n<tr>\n<td>comments</td>\n<td>显示页面评论模块（默认为true）</td>\n<td>否</td>\n<td>true</td>\n</tr>\n<tr>\n<td>top_img</td>\n<td>页面顶部图片</td>\n<td>否</td>\n<td>-</td>\n</tr>\n<tr>\n<td>mathjax</td>\n<td>显示mathjax（当设置mathjax的per_page: false时，才需要配置）</td>\n<td>否</td>\n<td>false</td>\n</tr>\n<tr>\n<td>katex</td>\n<td>显示katex（当设置katex的per_page: false时，才需要配置）</td>\n<td>否</td>\n<td>false</td>\n</tr>\n<tr>\n<td>aside</td>\n<td>显示侧边栏（默认为true）</td>\n<td>否</td>\n<td>true</td>\n</tr>\n<tr>\n<td>highlight_shrink</td>\n<td>配置代码框是否展开（true/false）（默认为设置中highlight_shrink的配置）</td>\n<td>否</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>tips:以上这个表格的md是这样写的</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs js\">| 属性名       | 描述                                                         | 是否必需 | 默认值        |<br>|------------|------------------------------------------------------------|--------|-------------|<br>| title      | 页面标题                                                    | 是     | -           |<br>| date       | 页面创建日期                                                | 是     | -           |<br>| type       | 标签、分类和友情链接三个页面需要配置                          | 是     | -           |<br>| updated    | 页面更新日期                                                | 否     | -           |<br>| description| 页面描述                                                    | 否     | -           |<br>| keywords   | 页面关键字                                                  | 否     | -           |<br>| comments   | 显示页面评论模块（默认为<span class=\"hljs-literal\">true</span>）                               | 否     | <span class=\"hljs-literal\">true</span>        |<br>| top_img    | 页面顶部图片                                                | 否     | -           |<br>| mathjax    | 显示mathjax（当设置mathjax的<span class=\"hljs-attr\">per_page</span>: <span class=\"hljs-literal\">false</span>时，才需要配置）  | 否     | <span class=\"hljs-literal\">false</span>       |<br>| katex      | 显示katex（当设置katex的<span class=\"hljs-attr\">per_page</span>: <span class=\"hljs-literal\">false</span>时，才需要配置）      | 否     | <span class=\"hljs-literal\">false</span>       |<br>| aside      | 显示侧边栏（默认为<span class=\"hljs-literal\">true</span>）                                     | 否     | <span class=\"hljs-literal\">true</span>        |<br>| highlight_shrink | 配置代码框是否展开（<span class=\"hljs-literal\">true</span>/<span class=\"hljs-literal\">false</span>）（默认为设置中highlight_shrink的配置） | 否     | -           |<br></code></pre></td></tr></tbody></table></figure>\n\n<hr>\n<h1 id=\"Hexo分类多层级\"><a href=\"#Hexo分类多层级\" class=\"headerlink\" title=\"Hexo分类多层级\"></a>Hexo分类多层级</h1><ol>\n<li><p><strong>父子分类</strong></p>\n<figure class=\"highlight ldif\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs ldif\"><span class=\"hljs-attribute\">categories</span>:<br><span class=\"hljs-literal\">-</span> Diary<br><span class=\"hljs-literal\">-</span> Life<br></code></pre></td></tr></tbody></table></figure>\n<p>会使分类Life成为Diary的子分类，而不是并列分类</p>\n</li>\n<li><p><strong>并列+子分类</strong><br>为文章添加多个分类，尝试一下list的方法</p>\n<figure class=\"highlight ldif\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs ldif\"><span class=\"hljs-attribute\">categories</span>:<br><span class=\"hljs-literal\">-</span> [Diary, PlayStation]<br><span class=\"hljs-literal\">-</span> [Diary, Games]<br><span class=\"hljs-literal\">-</span> [Life]<br></code></pre></td></tr></tbody></table></figure>\n<p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"Hexo常用操作命令\"><a href=\"#Hexo常用操作命令\" class=\"headerlink\" title=\"Hexo常用操作命令\"></a>Hexo常用操作命令</h1><p><img src=\"/images/hexo.png\"></p>\n<hr>\n<h1 id=\"Hexo-Obsidian高可用搭建说明\"><a href=\"#Hexo-Obsidian高可用搭建说明\" class=\"headerlink\" title=\"Hexo+Obsidian高可用搭建说明\"></a>Hexo+Obsidian高可用搭建说明</h1><h4 id=\"图片保存\"><a href=\"#图片保存\" class=\"headerlink\" title=\"图片保存\"></a>图片保存</h4><p>图片保存在Obsidian有自己的语法，要实现既可以在Ob上预览又可以在博客上显示出来需要一系列的设置</p>\n<ol>\n<li><strong>Ob上安装插件</strong><br><img src=\"/file-20241021180920049.png\"></li>\n<li><strong>配置Ob相关设置</strong><br><img src=\"/file-20241021181007212.png\"><br><img src=\"/file-20241021181012702.png\"></li>\n<li><strong>安装插件hexo-asset–image</strong></li>\n</ol>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs css\">npm install hexo-asset-<span class=\"hljs-selector-tag\">image</span> <span class=\"hljs-attr\">--save</span><br></code></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li><strong>修改_config.yml</strong><br>修改下列属性为true</li>\n</ol>\n<figure class=\"highlight nix\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">post_asset_folder:</span> <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>以上步骤完成之后便可以正常使用<br>每次在Ob中保存图片便会生成如下格式路径<br><img src=\"/images/file-20241021181834513.png\"></p>\n<hr>\n<h1 id=\"编辑器使用转型经验\"><a href=\"#编辑器使用转型经验\" class=\"headerlink\" title=\"编辑器使用转型经验\"></a>编辑器使用转型经验</h1><ul>\n<li>Obsidian</li>\n</ul>\n<blockquote>\n<p>适合编辑文本，编辑体验比vscode好<br>缺点是不适合插入图片，无法设置子分类，无法自动生成时间<br>使用简介，各种键入反应快捷</p>\n</blockquote>\n<ul>\n<li>Vscode，</li>\n</ul>\n<blockquote>\n<p>可以插入图片，可以设置子分类<br>缺点是编辑体验不如Obsidian好，预览显示有卡顿</p>\n</blockquote>\n<h1 id=\"压缩插件\"><a href=\"#压缩插件\" class=\"headerlink\" title=\"压缩插件\"></a>压缩插件</h1><p><strong>①Hexo-all-minifier</strong></p>\n<p><a href=\"https://github.com/chenzhutian/hexo-all-minifier/blob/master/README.md\">MD地址</a></p>\n<h1 id=\"Fluid主题\"><a href=\"#Fluid主题\" class=\"headerlink\" title=\"Fluid主题\"></a>Fluid主题</h1><h2 id=\"Tag插件\"><a href=\"#Tag插件\" class=\"headerlink\" title=\"Tag插件\"></a>Tag插件</h2><figure class=\"highlight django\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs django\"><span class=\"hljs-template-tag\">{% <span class=\"hljs-name\">note</span> success %}</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">文字 或者 `markdown` 均可</span><br><span class=\"language-xml\"></span><span class=\"hljs-template-tag\">{% <span class=\"hljs-name\">endnote</span> %}</span><br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"可选标签：\"><a href=\"#可选标签：\" class=\"headerlink\" title=\"可选标签：\"></a>可选标签：</h2><div class=\"note note-primary\">\n            <p>primary</p>\n          </div>\n<div class=\"note note-secondary\">\n            <p>secondary</p>\n          </div>\n<div class=\"note note-success\">\n            <p>success</p>\n          </div>\n<div class=\"note note-danger\">\n            <p>danger</p>\n          </div>\n<div class=\"note note-warning\">\n            <p>warning</p>\n          </div>\n<div class=\"note note-info\">\n            <p>info</p>\n          </div>\n<div class=\"note note-light\">\n            <p>light</p>\n          </div>\n\n<h2 id=\"行内标签\"><a href=\"#行内标签\" class=\"headerlink\" title=\"行内标签\"></a>行内标签</h2><figure class=\"highlight crystal\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-template-variable\">{% label primary <span class=\"hljs-variable\">@text</span> %}</span><br></code></pre></td></tr></tbody></table></figure>\n<p>可选标签：</p>\n<span class=\"label label-primary\">text</span>\n<span class=\"label label-default\">text</span>\n<span class=\"label label-info\">text</span>\n<span class=\"label label-success\">text</span>\n<span class=\"label label-warning\">text</span>\n<span class=\"label label-danger\">text</span>\n\n<h2 id=\"折叠块\"><a href=\"#折叠块\" class=\"headerlink\" title=\"折叠块\"></a>折叠块</h2><p>使用折叠块，可以折叠代码、图片、文字等任何内容，你可以在 markdown 中按如下格式：</p>\n<figure class=\"highlight django\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs django\"><span class=\"hljs-template-tag\">{% <span class=\"hljs-name\">fold</span> info @title %}</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">需要折叠的一段内容，支持 markdown</span><br><span class=\"language-xml\"></span><span class=\"hljs-template-tag\">{% <span class=\"hljs-name\">endfold</span> %}</span><br></code></pre></td></tr></tbody></table></figure>\n<p>info: 和行内标签类似的可选参数 title: 折叠块上的标题</p>\n<h2 id=\"按钮\"><a href=\"#按钮\" class=\"headerlink\" title=\"按钮\"></a>按钮</h2><figure class=\"highlight django\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs django\"><span class=\"hljs-template-tag\">{% <span class=\"hljs-name\">btn</span> url, text, title %}</span><br></code></pre></td></tr></tbody></table></figure>\n<p>url：跳转链接<br>text：显示的文字<br>title：鼠标悬停时显示的文字（可选）</p>\n<a class=\"btn\" href=\"url\" title=\"title\" target=\"_blank\">text</a>\n\n<h2 id=\"组图\"><a href=\"#组图\" class=\"headerlink\" title=\"组图\"></a>组图</h2><figure class=\"highlight scss\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs scss\">{% gi total n1-n2-... %}<br>  !<span class=\"hljs-selector-attr\">[]</span>(url)<br>  !<span class=\"hljs-selector-attr\">[]</span>(url)<br>  !<span class=\"hljs-selector-attr\">[]</span>(url)<br>  !<span class=\"hljs-selector-attr\">[]</span>(url)<br>  !<span class=\"hljs-selector-attr\">[]</span>(url)<br>{% endgi %}<br></code></pre></td></tr></tbody></table></figure>\n<p>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-…：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式</p>\n<p>如<code>{% gi 5 3-2 %}</code>&nbsp;示例，代表共 5 张图，第一行 3 张图，第二行 2 张图。</p>\n<hr>\n<h1 id=\"优秀Hexo示范（Stun）主题\"><a href=\"#优秀Hexo示范（Stun）主题\" class=\"headerlink\" title=\"优秀Hexo示范（Stun）主题\"></a>优秀Hexo示范（Stun）主题</h1><h5 id=\"Case-1-向往的博客\"><a href=\"#Case-1-向往的博客\" class=\"headerlink\" title=\"Case 1   向往的博客\"></a><a href=\"https://uuanqin.top/\">Case 1</a>   向往的博客</h5><h5 id=\"Case-2-stum主题作者的\"><a href=\"#Case-2-stum主题作者的\" class=\"headerlink\" title=\"Case 2  stum主题作者的\"></a><a href=\"https://liuyib.github.io/\">Case 2</a>  stum主题作者的</h5><h5 id=\"Case-3-路人\"><a href=\"#Case-3-路人\" class=\"headerlink\" title=\"Case 3   路人\"></a><a href=\"https://zhangjichengcc.github.io/blog/\">Case 3</a>   路人</h5><h5 id=\"Case-4-路人\"><a href=\"#Case-4-路人\" class=\"headerlink\" title=\"Case 4  路人\"></a><a href=\"https://longtong666.github.io/blog/\">Case 4</a>  路人</h5><h5 id=\"Case-5-清河的博客\"><a href=\"#Case-5-清河的博客\" class=\"headerlink\" title=\"Case 5  清河的博客\"></a><a href=\"https://lasonneil.github.io/\">Case 5</a>  清河的博客</h5><h5 id=\"Case6-君匡文集\"><a href=\"#Case6-君匡文集\" class=\"headerlink\" title=\"Case6 君匡文集\"></a><a href=\"https://literature.junkuang.fun/\">Case6</a> 君匡文集</h5><h1 id=\"Hexo运行报错合集\"><a href=\"#Hexo运行报错合集\" class=\"headerlink\" title=\"Hexo运行报错合集\"></a>Hexo运行报错合集</h1><h2 id=\"AssertionError-ERR-ASSERTION-The-expression-evaluated-to-a-falsy-value\"><a href=\"#AssertionError-ERR-ASSERTION-The-expression-evaluated-to-a-falsy-value\" class=\"headerlink\" title=\"AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:\"></a>AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:</h2><p><img src=\"/images/img-20241028124035029.png\"></p>\n<ul>\n<li>原因：<br><img src=\"/img-20241028124330560.png\"></li>\n<li>一开始我在网上搜索解决方法看到这句话，只有一个相关答案，我就在想有没有可能是转义错误，然后我测试了多个环节发现：</li>\n<li><img src=\"/images/img-20241028124124310.png\"></li>\n<li>如果我在最外层加这种反单引号会导致报<code>AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:</code>的错，我如果去掉单引号就变成了上面别人说的那种转义的错误，所以我就把这一整个删了发现正常了。</li>\n<li>后面我发现，好像是因为分割线紧贴了这句话导致这句话格式变了，不再是正文格式，中间多留一行就能解决<img src=\"/images/img-20241028125238738.png\"></li>\n<li>对于这种小错误我也是真无奈，还好从坑里爬出来了，下次注意！</li>\n</ul>\n<h1 id=\"Hexo配合MarkdownloadImage使用\"><a href=\"#Hexo配合MarkdownloadImage使用\" class=\"headerlink\" title=\"Hexo配合MarkdownloadImage使用\"></a>Hexo配合MarkdownloadImage使用</h1><p>跳转快捷键 Ctrl Shift O<br>配置在D盘Software MarkdownloadImage里面备份了一份</p>\n","categories":["Hexo"],"tags":["Hexo","GithubPages","Obsidian"]},{"title":"IO","url":"/posts/2248260274.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><strong>韩顺平B站IO流课程</strong></p>\n<span id=\"more\"></span>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><ul>\n<li><img src=\"/../images/img-20250713160953931.png\"></li>\n</ul>\n<h3 id=\"文件基础知识\"><a href=\"#文件基础知识\" class=\"headerlink\" title=\"文件基础知识\"></a>文件基础知识</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250713161119016.png\"></li>\n<li>输入还是输出是针对内存而言</li>\n</ul>\n<p><strong>常用文件操作</strong></p>\n<ul>\n<li><p><img src=\"/../images/img-20250713170149521.png\"></p>\n</li>\n<li><p>tips：一个汉字是<strong>3</strong>个字节</p>\n</li>\n<li><p><strong>文件的删除</strong></p>\n</li>\n<li><p><img src=\"/../images/img-20250716140207105.png\"></p>\n</li>\n<li><p>目录也是一种文件</p>\n</li>\n</ul>\n<h3 id=\"流的分类\"><a href=\"#流的分类\" class=\"headerlink\" title=\"流的分类\"></a>流的分类</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250716142759541.png\"></li>\n</ul>\n<h3 id=\"FileInputStream\"><a href=\"#FileInputStream\" class=\"headerlink\" title=\"FileInputStream\"></a>FileInputStream</h3><hr>\n<ul>\n<li>用于读取文件<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Test</span>  <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">readFile01</span><span class=\"hljs-params\">()</span> {  <br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\hello.txt\"</span>;  <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">readData</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;  <br>    java.io.<span class=\"hljs-type\">FileInputStream</span> <span class=\"hljs-variable\">fileInputStream</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>  <br>    <span class=\"hljs-keyword\">try</span> {  <br>        <span class=\"hljs-comment\">// 创建fileinputstream对象用于读取文件  </span><br>        fileInputStream = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">java</span>.io.FileInputStream(filePath);  <br>        <span class=\"hljs-keyword\">while</span> ((readData = fileInputStream.read()) != -<span class=\"hljs-number\">1</span>) {  <br>            System.out.print((<span class=\"hljs-type\">char</span>) readData); <span class=\"hljs-comment\">// 转成char显示  </span><br>        }  <br>    } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>    } <span class=\"hljs-keyword\">finally</span> {  <br>        <span class=\"hljs-keyword\">try</span> {  <br>            <span class=\"hljs-comment\">// 关闭文件流，释放资源  </span><br>            fileInputStream.close();  <br>        } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>        }  <br>    }  <br>}  <br>  <br><span class=\"hljs-comment\">/**  </span><br><span class=\"hljs-comment\"> * 读取文件中汉字，用字节数组的形式提高读取效率  </span><br><span class=\"hljs-comment\"> */</span>  <br><span class=\"hljs-meta\">@Test</span>  <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">readFile02</span><span class=\"hljs-params\">()</span> {  <br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\hello.txt\"</span>;  <br>    <span class=\"hljs-type\">byte</span>[] buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[<span class=\"hljs-number\">8</span>]; <span class=\"hljs-comment\">// 一次读8个字节  </span><br>    <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">readLen</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;  <br>    java.io.<span class=\"hljs-type\">FileInputStream</span> <span class=\"hljs-variable\">fileInputStream</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>    <span class=\"hljs-keyword\">try</span> {  <br>        <span class=\"hljs-comment\">// 创建fileinputstream对象用于读取文件  </span><br>        fileInputStream = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(filePath);  <br>        <span class=\"hljs-keyword\">while</span> ((readLen = fileInputStream.read(buf)) != -<span class=\"hljs-number\">1</span>) {  <br>            System.out.print(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(buf, <span class=\"hljs-number\">0</span>, readLen)); <span class=\"hljs-comment\">// 转成char显示  </span><br>        }  <br>    } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>    } <span class=\"hljs-keyword\">finally</span> {  <br>        <span class=\"hljs-keyword\">try</span> {  <br>            <span class=\"hljs-comment\">// 关闭文件流，释放资源  </span><br>            fileInputStream.close();  <br>        } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>        }  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n<li>讲解<blockquote>\n<p><strong><code>FileInputStream.read(byte[] b)</code>&nbsp;方法详解</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li><p><strong>功能</strong></p>\n<ul>\n<li>尝试从文件中读取最多&nbsp;<code>b.length</code>&nbsp;个字节的数据，并将其存储到字节数组&nbsp;<code>b</code>&nbsp;中。</li>\n<li>返回<strong>实际读取的字节数</strong>（整数），如果已到达文件末尾，则返回&nbsp;<code>-1</code>。</li>\n</ul>\n</li>\n<li><p><strong>执行流程</strong></p>\n<ul>\n<li><strong>读取数据</strong>：从文件当前位置开始，尝试读取&nbsp;<code>b.length</code>&nbsp;个字节到数组&nbsp;<code>b</code>&nbsp;中。</li>\n<li><strong>返回值</strong>：<ul>\n<li><strong>正整数</strong>：表示成功读取的字节数（可能小于&nbsp;<code>b.length</code>，例如文件剩余数据不足时）。</li>\n<li><strong>-1</strong>：表示已到达文件末尾（EOF，End of File）。</li>\n</ul>\n</li>\n<li><strong>文件指针移动</strong>：每次读取后，文件内部的指针会向后移动实际读取的字节数。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"FileOutputStream\"><a href=\"#FileOutputStream\" class=\"headerlink\" title=\"FileOutputStream\"></a>FileOutputStream</h3><hr>\n<ul>\n<li>用于往文件中写入内容<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"> <span class=\"hljs-meta\">@Test</span>  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">writeFile01</span><span class=\"hljs-params\">()</span> {  <br>        <span class=\"hljs-comment\">//创建对象  </span><br>        <span class=\"hljs-type\">FileOutputStream</span> <span class=\"hljs-variable\">fileOutputStream</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\a.txt\"</span>;  <br>        <span class=\"hljs-keyword\">try</span> {  <br>            fileOutputStream = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileOutputStream</span>(filePath);  <br>            <span class=\"hljs-comment\">// 写入字节数据  注意，char会自动转成int类型数据  </span><br><span class=\"hljs-comment\">//            fileOutputStream.write('B'); // 如果没有文件会自动创建  </span><br>            <span class=\"hljs-comment\">// 写入字符串  string.getBytes()会自动把字符串转换成字节数组  </span><br><span class=\"hljs-comment\">//            fileOutputStream.write(\"hello,world\".getBytes());  </span><br>            fileOutputStream.write(<span class=\"hljs-string\">\"hello,world\"</span>.getBytes(),<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">//从第三个开始写入5个字节  </span><br>  <br>            <span class=\"hljs-comment\">// 1. new FileOutputStream(filePath); 当写入内容会覆盖原来的内容  </span><br>            <span class=\"hljs-comment\">// 2. new FileOutputStream(filePath,true); 当写入内容会追加内容  </span><br>        } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>        } <span class=\"hljs-keyword\">finally</span> {  <br>            <span class=\"hljs-keyword\">try</span> {  <br>                fileOutputStream.close();  <br>            } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>            }  <br>        }  <br>    }<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h3 id=\"文件的拷贝\"><a href=\"#文件的拷贝\" class=\"headerlink\" title=\"文件的拷贝\"></a>文件的拷贝</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250725152504890.png\"></li>\n<li>源代码<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 创建文件输入流，将文件读取到程序  </span><br><span class=\"hljs-comment\">// 创建文件输出流，将读取到的文件数据，写入到指定的文件中  </span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"C:\\\\Users\\\\user\\\\Pictures\\\\100NZ502\\\\DSC_0002.JPG\"</span>;  <span class=\"hljs-comment\">// 源文件路径</span><br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">targetPath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\copy.jpg\"</span>; <span class=\"hljs-comment\">// 注意目标指向的一定是一个文件而不是目录  </span><br><span class=\"hljs-type\">FileInputStream</span> <span class=\"hljs-variable\">fileInputStream</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br><span class=\"hljs-type\">FileOutputStream</span> <span class=\"hljs-variable\">fileOutputStream</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>  <br><span class=\"hljs-keyword\">try</span> {  <br>    fileInputStream = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(filePath);  <br>    fileOutputStream = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileOutputStream</span>(targetPath);  <br>    <span class=\"hljs-comment\">// 定义字节数组提高读取效率  </span><br>    <span class=\"hljs-type\">byte</span>[] buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[<span class=\"hljs-number\">1024</span>];  <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">readLen</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;  <br>    <span class=\"hljs-comment\">// 一边读取一边写入  </span><br>    <span class=\"hljs-keyword\">while</span> ((readLen= fileInputStream.read(buf))!=-<span class=\"hljs-number\">1</span>){  <br>        fileOutputStream.write(buf,<span class=\"hljs-number\">0</span>,readLen); <span class=\"hljs-comment\">// 一定要用这个方法，否则会出现读取的字节不够  </span><br>    }  <br>    System.out.println(<span class=\"hljs-string\">\"拷贝完成\"</span>);  <br>} <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>}<span class=\"hljs-keyword\">finally</span> {  <br>    <span class=\"hljs-keyword\">try</span> {  <br>        <span class=\"hljs-keyword\">if</span>(fileInputStream!=<span class=\"hljs-literal\">null</span>){  <br>            fileInputStream.close();  <br>        }  <br>        <span class=\"hljs-keyword\">if</span>(fileOutputStream!=<span class=\"hljs-literal\">null</span>){  <br>            fileOutputStream.close();  <br>        }  <br>    } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h3 id=\"FileReader-FileWriter\"><a href=\"#FileReader-FileWriter\" class=\"headerlink\" title=\"FileReader FileWriter\"></a>FileReader FileWriter</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250726170457836.png\"></li>\n<li><img src=\"/../images/img-20250726170745619.png\"></li>\n<li>案例<ul>\n<li><img src=\"/../images/img-20250726171123365.png\"><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 单个字符读取</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {  <br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\story.txt\"</span>;  <br>    <span class=\"hljs-type\">FileReader</span> <span class=\"hljs-variable\">fileReader</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">data</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;  <br>    <span class=\"hljs-keyword\">try</span> {  <br>        fileReader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileReader</span>(filePath);  <br>        <span class=\"hljs-comment\">// 循环读取并输出  单个字符输出  </span><br>        <span class=\"hljs-keyword\">while</span> ((data = fileReader.read())!=-<span class=\"hljs-number\">1</span>){  <br>            System.out.print((<span class=\"hljs-type\">char</span>)data);  <br>        }  <br>    } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>    } <span class=\"hljs-keyword\">finally</span> {  <br>        <span class=\"hljs-keyword\">if</span>(fileReader!=<span class=\"hljs-literal\">null</span>){  <br>            <span class=\"hljs-keyword\">try</span> {  <br>                fileReader.close();  <br>            } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>            }  <br>        }  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure>\n<strong>改进</strong><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 使用字符数组批量读取</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {  <br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\story.txt\"</span>;  <br>    <span class=\"hljs-type\">FileReader</span> <span class=\"hljs-variable\">fileReader</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">readLength</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;  <br>    <span class=\"hljs-type\">char</span>[] buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">char</span>[<span class=\"hljs-number\">1024</span>]; <span class=\"hljs-comment\">// 数组长度自拟  </span><br>    <span class=\"hljs-keyword\">try</span> {  <br>        fileReader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileReader</span>(filePath);  <br>        <span class=\"hljs-comment\">// 循环读取并输出  批量读取 read(buf)返回的是实际读取到的字符数  </span><br>        <span class=\"hljs-comment\">// 如果返回 -1，说明文件读取结束  </span><br>        <span class=\"hljs-keyword\">while</span> ((readLength  = fileReader.read(buf))!=-<span class=\"hljs-number\">1</span>){  <br>            System.out.print(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(buf, <span class=\"hljs-number\">0</span>, readLength));  <br>        }  <br>    } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>    } <span class=\"hljs-keyword\">finally</span> {  <br>        <span class=\"hljs-keyword\">if</span>(fileReader!=<span class=\"hljs-literal\">null</span>){  <br>            <span class=\"hljs-keyword\">try</span> {  <br>                fileReader.close();  <br>            } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>            }  <br>        }  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"节点流和处理流\"><a href=\"#节点流和处理流\" class=\"headerlink\" title=\"节点流和处理流\"></a>节点流和处理流</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250726175712823.png\"></li>\n<li><img src=\"/../images/img-20250726175631097.png\"></li>\n</ul>\n<h4 id=\"节点流\"><a href=\"#节点流\" class=\"headerlink\" title=\"节点流\"></a>节点流</h4><hr>\n<ul>\n<li><img src=\"/../images/img-20250726180033917.png\"></li>\n</ul>\n<h4 id=\"处理流\"><a href=\"#处理流\" class=\"headerlink\" title=\"处理流\"></a>处理流</h4><hr>\n<ul>\n<li><img src=\"/../images/img-20250726180620421.png\"></li>\n</ul>\n<p><strong>BufferedReader</strong></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\story.txt\"</span>;  <br><span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">bufferedReader</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileReader</span>(filePath));  <br><span class=\"hljs-comment\">//读取  </span><br>String line;  <br><span class=\"hljs-comment\">// 按行读取  </span><br><span class=\"hljs-comment\">/*  </span><br><span class=\"hljs-comment\">注意这里的readline是按行读取  </span><br><span class=\"hljs-comment\"> */</span><span class=\"hljs-keyword\">while</span> ((line = bufferedReader.readLine()) != <span class=\"hljs-literal\">null</span>) {  <br>    System.out.println(line);  <br>}  <br>  <br><span class=\"hljs-comment\">/* 关闭流  </span><br><span class=\"hljs-comment\"> 注意： 这里只需要关闭 BufferedReader，因为底层的会自动去关闭节点流  </span><br><span class=\"hljs-comment\"> */</span>bufferedReader.close();<br></code></pre></td></tr></tbody></table></figure>\n\n<p><strong>BufferedWriter</strong></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\a.txt\"</span>;  <br><span class=\"hljs-comment\">//        BufferedWriter bufferedWriter  = new BufferedWriter(new FileWriter(filePath));  </span><br>        <span class=\"hljs-type\">BufferedWriter</span> <span class=\"hljs-variable\">bufferedWriter</span>  <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileWriter</span>(filePath,<span class=\"hljs-literal\">true</span>));<span class=\"hljs-comment\">// 追加写入  </span><br>        bufferedWriter.write(<span class=\"hljs-string\">\"输入第一句话\"</span>);  <br>        <span class=\"hljs-comment\">// 插入一个和系统相关的换行  </span><br>        bufferedWriter.newLine();  <br>        bufferedWriter.write(<span class=\"hljs-string\">\"输入第二句话\"</span>);  <br>        bufferedWriter.newLine();  <br>        bufferedWriter.write(<span class=\"hljs-string\">\"输入第三句话\"</span>);  <br>        bufferedWriter.newLine();  <br>        <span class=\"hljs-comment\">// 关闭流  </span><br>        <span class=\"hljs-comment\">// 注意：关闭外层流即可，底层会自动关闭节点流  </span><br>        bufferedWriter.close();  <br>    }<br></code></pre></td></tr></tbody></table></figure>\n\n<p><strong>拷贝</strong></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sourcePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\a.txt\"</span>;  <br><span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">destPath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\a_copy.txt\"</span>;  <br><span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">br</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br><span class=\"hljs-type\">BufferedWriter</span> <span class=\"hljs-variable\">bw</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>String line ;  <br><span class=\"hljs-keyword\">try</span> {  <br>    br =<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileReader</span>(sourcePath));  <br>    bw = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileWriter</span>(destPath));  <br>    <span class=\"hljs-keyword\">while</span> ((line=br.readLine())!=<span class=\"hljs-literal\">null</span>){  <br>        <span class=\"hljs-comment\">// readline 是读取一行写入一行，但是没有换行，所以要手动换行  </span><br>        bw.write(line);  <br>        bw.newLine();  <br>    }  <br>} <span class=\"hljs-keyword\">catch</span> (Exception e) {  <br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>}<span class=\"hljs-keyword\">finally</span> {  <br>    <span class=\"hljs-keyword\">try</span> {  <br>        <span class=\"hljs-comment\">//关闭外层流  </span><br>        <span class=\"hljs-keyword\">if</span>(br!=<span class=\"hljs-literal\">null</span>)  <br>            br.close();  <br>        <span class=\"hljs-keyword\">if</span>(bw!=<span class=\"hljs-literal\">null</span>)  <br>            bw.close();  <br>    } <span class=\"hljs-keyword\">catch</span> (Exception e) {  <br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>    }  <br>}  <br><span class=\"hljs-comment\">/**  </span><br><span class=\"hljs-comment\"> * 注意：  </span><br><span class=\"hljs-comment\"> * BufferedReader或者BufferedWriter是按照字符操作，  </span><br><span class=\"hljs-comment\"> * 不要去操作二进制文件，可能会造成文件损坏  </span><br><span class=\"hljs-comment\"> */</span><br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><p>实际工作的是节点流处理流只是包装增强功能，关闭流的时候只用关闭bufferedReader，然后他会自动关闭底层的字节流（当前的BufferedReader是包装流）</p>\n</li>\n<li><p>二进制文件有：图片 声音 视频 </p>\n</li>\n<li><p><img src=\"/../images/img-20250816152905643.png\"></p>\n</li>\n<li><p><img src=\"/../images/img-20250816153221128.png\"></p>\n</li>\n</ul>\n<p><strong>二进制拷贝</strong></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*  拷贝图片 String sourcePicturePath = \"C://Users//Yething//Pictures//Screenshots//cyxxtf.jpg\";   </span><br><span class=\"hljs-comment\">String destPicturePath = \"E://io//bufferedCopyPicture.jpg\";*/</span>  <br>   <span class=\"hljs-comment\">//拷贝视频  </span><br>   <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">sourcePicturePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"C://Users//Yething//Videos//5月19日//[DLPanda.com][30就拍鸟的ALLEN LAN]7513506201276976419.mp4\"</span>;  <br>   <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">destPicturePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"E://io//bufferedCopyVideo.mp4\"</span>;  <br>   <span class=\"hljs-type\">BufferedInputStream</span> <span class=\"hljs-variable\">bis</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>   <span class=\"hljs-type\">BufferedOutputStream</span> <span class=\"hljs-variable\">bos</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;  <br>  <br>   <span class=\"hljs-keyword\">try</span> {  <br>       <span class=\"hljs-comment\">// 因为FileInputStream是InputStream的子类  </span><br>       bis = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedInputStream</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(sourcePicturePath));  <br>       bos = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedOutputStream</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileOutputStream</span>(destPicturePath));  <br>  <br>       <span class=\"hljs-comment\">// 循环读取文件，并写入到目标位置  </span><br>       <span class=\"hljs-type\">byte</span>[] buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[<span class=\"hljs-number\">1024</span>]; <span class=\"hljs-comment\">//提升读取效率  </span><br>       <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">readLength</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;  <br>       <span class=\"hljs-keyword\">while</span> ((readLength = bis.read(buf)) != -<span class=\"hljs-number\">1</span>) {  <br>           bos.write(buf, <span class=\"hljs-number\">0</span>, readLength);  <br>       }  <br>       System.out.println(<span class=\"hljs-string\">\"拷贝完成\"</span>);  <br>   } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>       <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>   } <span class=\"hljs-keyword\">finally</span> {  <br>       <span class=\"hljs-comment\">//关闭流，关闭外层流，因为会自动关闭底层的字节流  </span><br>  <br>       <span class=\"hljs-keyword\">try</span> {  <br>           <span class=\"hljs-keyword\">if</span>(bis!=<span class=\"hljs-literal\">null</span>){  <br>               bis.close();  <br>           }  <br>           <span class=\"hljs-keyword\">if</span>(bos!=<span class=\"hljs-literal\">null</span>){  <br>               bos.close();  <br>           }  <br>       } <span class=\"hljs-keyword\">catch</span> (IOException e) {  <br>           <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);  <br>       }  <br>   }<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h4 id=\"节点流和处理流的区别和联系\"><a href=\"#节点流和处理流的区别和联系\" class=\"headerlink\" title=\"节点流和处理流的区别和联系\"></a>节点流和处理流的区别和联系</h4><hr>\n<ul>\n<li><img src=\"/../images/img-20250816135707810.png\"></li>\n<li>用修饰器模式，利用对象动态绑定机制，绑定到对应的实现子类</li>\n</ul>\n<h3 id=\"对象流\"><a href=\"#对象流\" class=\"headerlink\" title=\"对象流\"></a>对象流</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250816155933888.png\"></li>\n<li><img src=\"/../images/img-20250816160108378.png\"></li>\n<li><img src=\"/../images/img-20250816160155431.png\"></li>\n<li></li>\n<li>保存数据的时候把数据类型也保存下来<ul>\n<li>以前是：保存值</li>\n<li>现在是：保存值和数据类型，比如100是Integer类型</li>\n</ul>\n</li>\n<li><img src=\"/../images/img-20250816155624566.png\"></li>\n</ul>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ObjectInputStream_</span> {  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException, ClassNotFoundException {  <br>        <span class=\"hljs-comment\">// 指定反序列化的文件  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\ioObject_Output_Stream.bat\"</span>;  <br>        <span class=\"hljs-type\">ObjectInputStream</span> <span class=\"hljs-variable\">ois</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectInputStream</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(filePath));  <br>  <br>        <span class=\"hljs-comment\">// 注意：反序列化的顺序要和当初序列化的顺序相同  </span><br>        System.out.println(ois.readInt());  <br>        System.out.println(ois.readBoolean());  <br>        System.out.println(ois.readChar());  <br>        System.out.println(ois.readDouble());  <br>        System.out.println(ois.readUTF());  <br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">dog</span> <span class=\"hljs-operator\">=</span> ois.readObject();  <br>        System.out.println(<span class=\"hljs-string\">\"运行类型 = \"</span>+dog.getClass());  <br>        System.out.println(<span class=\"hljs-string\">\"dog信息 = \"</span>+dog);  <br>  <br>        <span class=\"hljs-comment\">//如果需要调用Dog的方法，需要向下转型  </span><br>        <span class=\"hljs-type\">Dog</span> <span class=\"hljs-variable\">dog1</span>  <span class=\"hljs-operator\">=</span> (Dog) dog;  <br>        System.out.println(<span class=\"hljs-string\">\"dog1信息：\"</span>+dog1.getName());  <br>        <span class=\"hljs-comment\">// 关闭流，关闭外层流  </span><br>        ois.close();  <br>    }  <br>}<br>  <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Serializable</span> {  <br>    <span class=\"hljs-keyword\">private</span> String name;  <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> age;  <br>    <span class=\"hljs-comment\">// serialVersionUID 序列化的版本号，可以提高兼容性，加了下面这个之后不会认为是一个全新的类，会认为是Dog的一个升级版  </span><br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span>  <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">serialVersionUID</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1L</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Dog</span><span class=\"hljs-params\">(String name, <span class=\"hljs-type\">int</span> age)</span> {  <br>        <span class=\"hljs-built_in\">this</span>.name = name;  <br>        <span class=\"hljs-built_in\">this</span>.age = age;  <br>    }  <br>    <span class=\"hljs-meta\">@Override</span>  <br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span> {  <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Dog{\"</span> +  <br>                <span class=\"hljs-string\">\"name='\"</span> + name + <span class=\"hljs-string\">'\\''</span> +  <br>                <span class=\"hljs-string\">\", age=\"</span> + age +  <br>                <span class=\"hljs-string\">'}'</span>;  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><img src=\"/../images/img-20250816162809142.png\"></li>\n<li><img src=\"/../images/img-20250816170137173.png\"></li>\n<li>第六个点<img src=\"/../images/img-20250816171135919.png\"></li>\n</ul>\n<h3 id=\"标准输入输出流\"><a href=\"#标准输入输出流\" class=\"headerlink\" title=\"标准输入输出流\"></a>标准输入输出流</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250817104533840.png\"><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InputAndOutput</span> {  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {  <br>        <span class=\"hljs-comment\">// System类的 public final static InputStream in = null;  </span><br>        <span class=\"hljs-comment\">// System.in 编译类型 InputStream     </span><br>        <span class=\"hljs-comment\">// System.in 运行类型 BufferedInputStream   </span><br>        <span class=\"hljs-comment\">// 表示标准输入 键盘  </span><br>        System.out.println(System.in.getClass());  <br>  <br>        <span class=\"hljs-comment\">// System类的 public final static PrintStream out = null;  </span><br>        <span class=\"hljs-comment\">// System.out 编译类型 PrintStream      </span><br>        <span class=\"hljs-comment\">// System.out 运行类型 PrintStream      </span><br>        <span class=\"hljs-comment\">// 表示标准输出 显示器  </span><br>        System.out.println(System.out.getClass());  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h3 id=\"转换流\"><a href=\"#转换流\" class=\"headerlink\" title=\"转换流\"></a>转换流</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250817105122608.png\"></li>\n<li><img src=\"/../images/img-20250817105804208.png\"></li>\n<li>把字节流转换成字符流</li>\n<li>学IO流最困难的是要知道在什么时候用什么流</li>\n<li>ANSI是国标码，其他国家也有自己的国标码，是根据当前安装的系统决定是哪个国家的国标码<img src=\"/../images/img-20250817112052421.png\"></li>\n<li>出现乱码的原因是没有指定读取文件的编码方式</li>\n<li>转换流可以把字节流转换成字符流</li>\n</ul>\n<p>正式学习</p>\n<ul>\n<li><img src=\"/../images/img-20250817112833190.png\"></li>\n</ul>\n<h4 id=\"InputStreamReader\"><a href=\"#InputStreamReader\" class=\"headerlink\" title=\"InputStreamReader\"></a>InputStreamReader</h4><ul>\n<li><img src=\"/../images/img-20250817112610432.png\"></li>\n<li>传入字节流，然后变成字符流，完成字节流到字符流的转换</li>\n<li><img src=\"/../images/img-20250817112723611.png\"></li>\n<li><img src=\"/../images/img-20250817113054086.png\"><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException {  <br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\hello.txt\"</span>;  <br>    <span class=\"hljs-comment\">// 把FileInputStream 转成 InputStreamReader    // 指定编码GBK  </span><br>    <span class=\"hljs-type\">InputStreamReader</span> <span class=\"hljs-variable\">isr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(Files.newInputStream(Paths.get(filePath)), <span class=\"hljs-string\">\"GBK\"</span>);  <br>    <span class=\"hljs-comment\">// 把InputStreamReader 转成 BufferedReader    /*    我自己的理解：  </span><br>    把字节流转换成字符流，这里用到了转换流    然后把字符流用包装器来接收之后再读取，但是弹幕说buffer只是让效率变得更高，不用也行<br>     */    <span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">br</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(isr);  <br>    <span class=\"hljs-comment\">//现在再读取  </span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">s</span> <span class=\"hljs-operator\">=</span> br.readLine();  <br>    System.out.println(<span class=\"hljs-string\">\"打印出来的内容： \"</span>+s);  <br>    <span class=\"hljs-comment\">// 关闭外层流  </span><br>    br.close();  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h4 id=\"OutputStreamWriter\"><a href=\"#OutputStreamWriter\" class=\"headerlink\" title=\"OutputStreamWriter\"></a>OutputStreamWriter</h4><ul>\n<li><img src=\"/../images/img-20250817143944890.png\"><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OutputStreamWriter_</span> {  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException {  <br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">filePath</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"e:\\\\io\\\\out.txt\"</span>;  <br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">charset</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"utf8\"</span>;  <br>        <span class=\"hljs-type\">OutputStreamWriter</span> <span class=\"hljs-variable\">osw</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OutputStreamWriter</span>(Files.newOutputStream(Paths.get(filePath)),charset);  <br>        osw.write(<span class=\"hljs-string\">\"hi,你好编程\"</span>);  <br>        osw.close();  <br>        System.out.println(<span class=\"hljs-string\">\"按照\"</span>+charset+<span class=\"hljs-string\">\"格式保存文件完成\"</span>);  <br>        <span class=\"hljs-comment\">//这里没有用buffer也可以，buffer只是增加效率</span><br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h4 id=\"PrintWriter\"><a href=\"#PrintWriter\" class=\"headerlink\" title=\"PrintWriter\"></a>PrintWriter</h4><ul>\n<li><p><img src=\"/../images/img-20250817145920635.png\"></p>\n</li>\n<li><p>打印流只有输出流</p>\n</li>\n<li><p><img src=\"/../images/img-20250817145944517.png\"></p>\n</li>\n<li><p><img src=\"/../images/img-20250817152023470.png\"></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PrintWriter_</span> {  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException {  <br><span class=\"hljs-comment\">//        PrintWriter printWriter = new PrintWriter(System.out); // 指向显示器  </span><br>        <span class=\"hljs-type\">PrintWriter</span> <span class=\"hljs-variable\">printWriter</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PrintWriter</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileWriter</span>(<span class=\"hljs-string\">\"e:\\\\io\\\\printwriter.txt\"</span>)); <span class=\"hljs-comment\">// 指向显示器  </span><br>        printWriter.print(<span class=\"hljs-string\">\"hi,Java你好\"</span>);  <br>        printWriter.close();  <br>    }  <br>}<br><br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h3 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250817162459929.png\"></li>\n<li><img src=\"/../images/img-20250817163953459.png\"></li>\n<li><img src=\"/../images/img-20250817164007149.png\"></li>\n<li><img src=\"/../images/img-20250817164138622.png\"></li>\n<li></li>\n</ul>\n","categories":["Java"],"tags":["IO流","Java"]},{"title":"Java大纲","url":"/posts/2302726656.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><strong>Java存活路线</strong></p>\n<span id=\"more\"></span>\n<h1 id=\"一阶段：Java-进阶必备技术栈\"><a href=\"#一阶段：Java-进阶必备技术栈\" class=\"headerlink\" title=\"一阶段：Java&nbsp;进阶必备技术栈\"></a>一阶段：Java&nbsp;进阶必备技术栈</h1><h2 id=\"01-项目性能优化\"><a href=\"#01-项目性能优化\" class=\"headerlink\" title=\"01 项目性能优化\"></a>01 项目性能优化</h2><ul>\n<li><p>性能问题分析理论：3S&nbsp;定理</p>\n</li>\n<li><p>性能指标：RT、TPS、并发数…</p>\n</li>\n<li><p>压测监控平台：Docker、InfluxDB、Grafana、Prometheus 和 node_exporter 环境搭建</p>\n</li>\n<li><p>梯度压测：分析接口性能瓶颈</p>\n</li>\n<li><p>分布式压测：构建百万次请求的压力</p>\n</li>\n<li><p>服务容器优化：Tomcat、I/O 模型、Undertow&nbsp;调优</p>\n</li>\n<li><p>数据库调优：影响数据库性能因素</p>\n</li>\n<li><p>OpenResty 调优</p>\n</li>\n<li><p>多级缓存调优</p>\n</li>\n<li><p>JVM 调优</p>\n</li>\n</ul>\n<h2 id=\"02-JVM虚拟机\"><a href=\"#02-JVM虚拟机\" class=\"headerlink\" title=\"02 JVM虚拟机\"></a>02 JVM虚拟机</h2><ul>\n<li><p>JVM&nbsp;基本常识与整体架构</p>\n</li>\n<li><p>类加载子系统：加载时机、加载过程</p>\n</li>\n<li><p>类加载器详解</p>\n</li>\n<li><p>JVM 加载机制剖析：一个类的一生</p>\n</li>\n<li><p>双亲委派与打破双亲委派</p>\n</li>\n<li><p>自定义类加载器</p>\n</li>\n<li><p>JVM&nbsp;运行时数据区：堆、虚拟机栈、本地方法栈、方法区、字符串常量池、程序计数器</p>\n</li>\n<li><p>JVM 内存模型变迁</p>\n</li>\n<li><p>栈帧剖析与栈异常案例</p>\n</li>\n<li><p>字符串常量池如何存储和查找数据</p>\n</li>\n<li><p>方法区存储什么，永久代与元空间是什么关系</p>\n</li>\n<li><p>一个对象的一辈子：对象创建流程与内存分配</p>\n</li>\n<li><p>对象怎样才会进入老年代？内存担保机制</p>\n</li>\n<li><p>解剖对象这只小麻雀：对象内存布局，对象头 Header 的 MarkWord 和 KlassPoint</p>\n</li>\n<li><p>如何定位一个对象</p>\n</li>\n<li><p>GC 基本原理：什么是垃圾、如何找到垃圾、如何清除垃圾、用什么清除垃圾</p>\n</li>\n<li><p>垃圾收集器剖析：Parallel、Serial、CMS、G1、ZGC</p>\n</li>\n<li><p>Minor GC 、Major GC 和 Full GC</p>\n</li>\n<li><p>JVM&nbsp;核心参数：标准参数、非标准参数、不稳定参数</p>\n</li>\n<li><p>JVM&nbsp;常用指令：jps、jstat、jinfo、jhat、jmap</p>\n</li>\n<li><p>JVM&nbsp;调优工具：VisualVM、GC&nbsp;Easy、PerfMa、MAT</p>\n</li>\n<li><p>GC&nbsp;日志分析</p>\n</li>\n<li><p>GC&nbsp;日志分析工具</p>\n</li>\n<li><p>内存溢出与泄露案例</p>\n</li>\n<li><p>检测死锁案例</p>\n</li>\n<li><p>JVM&nbsp;调优实战案例：</p>\n</li>\n<li><p>堆内存和元空间优化</p>\n</li>\n<li><p>堆栈优化</p>\n</li>\n<li><p>吞吐量优先策略</p>\n</li>\n<li><p>响应时间优先策略</p>\n</li>\n<li><p>G1 全功能垃圾收集策略</p>\n</li>\n<li><p>JVM调优实战案例</p>\n<ul>\n<li><ul>\n<li>堆内存和元空间优化</li>\n</ul>\n</li>\n<li>堆栈优化</li>\n<li>吞吐量优先策略</li>\n<li>响应时间优先策略</li>\n<li>G1 全功能垃圾收集策略</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"03-多线程与并发编程\"><a href=\"#03-多线程与并发编程\" class=\"headerlink\" title=\"03 多线程与并发编程\"></a>03 多线程与并发编程</h2><ul>\n<li><p>线程和进程、并发与并行、上下文切换</p>\n</li>\n<li><p>多线程并发中的线程安全问题</p>\n</li>\n<li><p>多线程并发的三个特性：原子性、可见性、顺序性分析</p>\n</li>\n<li><p>指令重排序、happens-before 规则</p>\n</li>\n<li><p>JMM&nbsp;模型深度剖析：JSR-133: Java Memory Model and Thread Specification</p>\n</li>\n<li><p>Synchronized&nbsp;原理分析</p>\n</li>\n<li><p>锁优化&amp;锁升级</p>\n</li>\n<li><p>Volatile&nbsp;原理与源码分析</p>\n</li>\n<li><p>多线程在 JVM 中的实现原理剖析</p>\n</li>\n<li><p>CAS 算法和 ABA 问题</p>\n</li>\n<li><p>显示锁和&nbsp;AQS&nbsp;底层原理分析</p>\n</li>\n<li><p>AQS&nbsp;共享锁实现原理</p>\n</li>\n<li><p>ReentrantLock 重入锁源码分析</p>\n</li>\n<li><p>ReentrantReadWriteLock 读写锁</p>\n</li>\n<li><p>并发容器深度剖析</p>\n</li>\n<li><p>CAS&nbsp;原子操作及相关类</p>\n<ul>\n<li><p>基本数据类型：AtomicInteger、AtomicLong、AtomicBoolean</p>\n</li>\n<li><p>数组：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>\n</li>\n<li><p>引用类型：AtomicReference</p>\n</li>\n</ul>\n</li>\n<li><p>并发编程工具掌握：CountDownLatch、Semaphore、CyclicBarrier</p>\n</li>\n<li><p>Future 和 FutureTask</p>\n</li>\n<li><p>线程池工作原理</p>\n</li>\n<li><p>ThreadLocal&nbsp;底层原理</p>\n</li>\n</ul>\n<h2 id=\"04-网络编程\"><a href=\"#04-网络编程\" class=\"headerlink\" title=\"04 网络编程\"></a>04 网络编程</h2><ul>\n<li><p>网络通信协议：TCP/IP 协议集</p>\n</li>\n<li><p>TCP/IP 五层模型和 OSI 模型详解</p>\n</li>\n<li><p>TCP 三次握手和四次挥手机制</p>\n</li>\n<li><p>TCP 与 UDP 协议</p>\n</li>\n<li><p>从输入 URL 地址到显示网页经历了哪些过程</p>\n</li>\n<li><p>HTTP/1.0 与 HTTP/1.1 的区别</p>\n</li>\n<li><p>URI 与 URL 的区别</p>\n</li>\n<li><p>HTTP 与 HTTPS 的区别</p>\n</li>\n<li><p>同步和异步、阻塞和非阻塞</p>\n</li>\n<li><p>五种&nbsp;I/O&nbsp;模型：阻塞&nbsp;I/O&nbsp;模型、非阻塞&nbsp;I/O&nbsp;模型、多路复用&nbsp;I/O&nbsp;模型、信号驱动&nbsp;I/O&nbsp;模型、异步&nbsp;I/O&nbsp;模型</p>\n</li>\n<li><p>JAVA&nbsp;网络编程模型：BIO、NIO、AIO</p>\n</li>\n<li><p>NIO 多路复用深入剖析：Selector、Channel 与 SelectionKey</p>\n</li>\n<li><p>NIO 案例 01：客户端与服务器之间通信</p>\n</li>\n<li><p>NIO 案例 02：网络聊天室 V1.0</p>\n</li>\n<li><p>Netty&nbsp;总体架构设计</p>\n</li>\n<li><p>Netty&nbsp;线程模型：单线程、多线程与 Netty 线程模型</p>\n</li>\n<li><p>Netty&nbsp;核心组件：Bootstrap、EventLoopGroup、Channel 与 ChannelHandlerContext 等</p>\n</li>\n<li><p>Netty 案例 03：客户端与服务器之间通信</p>\n</li>\n<li><p>Netty 案例 04：网络聊天室 V2.0</p>\n</li>\n<li><p>Netty 编解码器</p>\n</li>\n<li><p>RPC&nbsp;通信原理</p>\n</li>\n<li><p>RPC&nbsp;的设计架构与思想</p>\n</li>\n<li><p>RPC&nbsp;架构完整调用流程</p>\n</li>\n<li><p>案例 05：手写一个 RPC 框架 HeroRPC</p>\n</li>\n<li><p>案例 06：手写一个 Tomcat</p>\n</li>\n<li><p>案例 07：600W+ 连接网络应用实战</p>\n</li>\n</ul>\n<h1 id=\"二阶段：海量数据存储专题\"><a href=\"#二阶段：海量数据存储专题\" class=\"headerlink\" title=\"二阶段：海量数据存储专题\"></a>二阶段：海量数据存储专题</h1><h2 id=\"01MySQL进阶\"><a href=\"#01MySQL进阶\" class=\"headerlink\" title=\"01MySQL进阶\"></a>01MySQL进阶</h2><ul>\n<li><p>MySQL&nbsp;应用架构：内存结构、磁盘结构</p>\n</li>\n<li><p>MySQL&nbsp;体系架构</p>\n</li>\n<li><p>MySQL&nbsp;运行机制</p>\n</li>\n<li><p>一条&nbsp;SQL&nbsp;语句的完整执行流程</p>\n</li>\n<li><p>Buffer&nbsp;Pool</p>\n</li>\n<li><p>日志缓冲</p>\n</li>\n<li><p>内存数据落盘</p>\n</li>\n<li><p>CheckPoint</p>\n</li>\n<li><p>Double&nbsp;Write</p>\n</li>\n<li><p>存储引擎原理：InnoDB、MyISAM</p>\n</li>\n<li><p>索引的数据结构：B+&nbsp;树、为什么不用红黑树、二叉树、B&nbsp;树？</p>\n</li>\n<li><p>索引原理</p>\n</li>\n<li><p>索引分析与优化建议</p>\n</li>\n<li><p>索引下推&nbsp;ICP</p>\n</li>\n<li><p>聚簇索引，辅助索引</p>\n</li>\n<li><p>查询分析与优化</p>\n</li>\n<li><p>事务&nbsp;ACID&nbsp;特性</p>\n</li>\n<li><p>事务控制的演进</p>\n</li>\n<li><p>事务隔离级别</p>\n</li>\n<li><p>LBCC&nbsp;与&nbsp;MVCC</p>\n</li>\n<li><p>ReadView：快照读、当前读</p>\n</li>\n<li><p>版本链</p>\n</li>\n<li><p>日志：Undo&nbsp;log、redo&nbsp;log、binlog</p>\n</li>\n<li><p>锁：全局锁、表锁、行锁【记录锁、间隙锁、临键锁、插入意向锁】、读锁、写锁</p>\n</li>\n<li><p>复杂&nbsp;SQL&nbsp;加锁分析</p>\n</li>\n<li><p>死锁原理</p>\n</li>\n</ul>\n<h2 id=\"02-海量数据存储与优化\"><a href=\"#02-海量数据存储与优化\" class=\"headerlink\" title=\"02 海量数据存储与优化\"></a>02 海量数据存储与优化</h2><ul>\n<li><p>数据库压力测试</p>\n</li>\n<li><p>数据库的连接池优化</p>\n</li>\n<li><p>SQL&nbsp;语句优化：执行计划</p>\n</li>\n<li><p>索引优化</p>\n</li>\n<li><p>Limit&nbsp;优化</p>\n</li>\n<li><p>子查询优化</p>\n</li>\n<li><p>SQL&nbsp;语句性能分析</p>\n</li>\n<li><p>慢查询日志</p>\n</li>\n<li><p>线程使用情况分析</p>\n</li>\n<li><p>集群架构设计</p>\n</li>\n<li><p>主从模式高可用</p>\n</li>\n<li><p>双主模式</p>\n</li>\n<li><p>分库分表</p>\n</li>\n<li><p>分库分表实战</p>\n</li>\n<li><p>ShardingSphere</p>\n</li>\n<li><p>Sharding-JDBC</p>\n</li>\n<li><p>数据分片剖析实战</p>\n</li>\n<li><p>读写分离剖析实战</p>\n</li>\n<li><p>分布式事务剖析实战</p>\n</li>\n<li><p>Sharding-Proxy&nbsp;实战</p>\n</li>\n<li><p>Sharding&nbsp;Sphere&nbsp;源码分析</p>\n</li>\n<li><p>MyCat&nbsp;核心概念</p>\n</li>\n<li><p>MyCat&nbsp;架构剖析</p>\n</li>\n<li><p>MyCat&nbsp;配置详解</p>\n</li>\n<li><p>MyCat&nbsp;管理命令详解</p>\n</li>\n<li><p>MyCat&nbsp;分片规则详解</p>\n</li>\n<li><p>MyCat&nbsp;分库分表</p>\n</li>\n<li><p>MyCat&nbsp;读写分离</p>\n</li>\n<li><p>MyCat&nbsp;强制路由</p>\n</li>\n<li><p>MyCat&nbsp;注解技术</p>\n</li>\n<li><p>MyCat&nbsp;核心技术分析</p>\n</li>\n<li><p>MyCat&nbsp;分布式事务的实现</p>\n</li>\n<li><p>MyCat&nbsp;SQL&nbsp;路由的实现</p>\n</li>\n<li><p>MyCat&nbsp;跨库&nbsp;JSON&nbsp;的实现</p>\n</li>\n<li><p>MyCat&nbsp;数据汇聚和排序的实现</p>\n</li>\n</ul>\n<h2 id=\"03-MongoDB\"><a href=\"#03-MongoDB\" class=\"headerlink\" title=\"03&nbsp;MongoDB\"></a>03&nbsp;MongoDB</h2><ul>\n<li><p>MongoDB&nbsp;体系结构</p>\n</li>\n<li><p>MongoDB&nbsp;存储原理</p>\n</li>\n<li><p>MongoDB&nbsp;存储引擎</p>\n</li>\n<li><p>MongoDB&nbsp;索引和&nbsp;explain&nbsp;分析</p>\n</li>\n<li><p>MongoDB&nbsp;索引底层原理分析</p>\n</li>\n<li><p>MongoDB&nbsp;主备切换</p>\n</li>\n<li><p>MongoDB&nbsp;企业实战</p>\n</li>\n<li><p>MongoDB&nbsp;集群高可用</p>\n</li>\n<li><p>复制集&nbsp;replica&nbsp;sets</p>\n</li>\n<li><p>分片集群&nbsp;Shard&nbsp;Cluster</p>\n</li>\n<li><p>MongoDB&nbsp;安全认证</p>\n</li>\n<li><p>监控服务（Mong&nbsp;oOps&nbsp;Manager）</p>\n</li>\n<li><p>MongoDB&nbsp;备份</p>\n</li>\n</ul>\n<h2 id=\"04-FastDFS\"><a href=\"#04-FastDFS\" class=\"headerlink\" title=\"04&nbsp;FastDFS\"></a>04&nbsp;FastDFS</h2><ul>\n<li><p>分布式文件系统</p>\n</li>\n<li><p>FastDFS&nbsp;特性</p>\n</li>\n<li><p>FastDFS&nbsp;的构成</p>\n</li>\n<li><p>Linux&nbsp;下&nbsp;FastDFS&nbsp;的安装</p>\n</li>\n<li><p>Java&nbsp;访问&nbsp;FastDFS</p>\n</li>\n<li><p>FastDFS&nbsp;系统架构</p>\n</li>\n<li><p>FastDFS&nbsp;功能原理</p>\n</li>\n<li><p>FastDFS&nbsp;集群和配置优化</p>\n</li>\n<li><p>FastDFS&nbsp;企业实战</p>\n</li>\n<li><p>Spring Boot&nbsp;访问&nbsp;FastDFS</p>\n</li>\n</ul>\n<h1 id=\"三阶段：常用开发框架解读专题\"><a href=\"#三阶段：常用开发框架解读专题\" class=\"headerlink\" title=\"三阶段：常用开发框架解读专题\"></a>三阶段：常用开发框架解读专题</h1><hr>\n<h2 id=\"01-Spring-源码\"><a href=\"#01-Spring-源码\" class=\"headerlink\" title=\"01&nbsp;Spring 源码\"></a>01&nbsp;<strong>Spring 源码</strong></h2><ul>\n<li><p>Spring&nbsp;源码阅读前沿</p>\n</li>\n<li><p>Spring 创建对象代码演变及 IoC&nbsp;容器初始化</p>\n</li>\n<li><p>手写一个 Spring 框架案例</p>\n</li>\n<li><p>Spring&nbsp;面向对象 OOAD 和七大设计原则</p>\n</li>\n<li><p>Spring-IoC 模块的面向对象设计</p>\n</li>\n<li><p>Spring&nbsp;面向对象方式手写 IoC 流程</p>\n</li>\n<li><p>Spring-IoC 源码阅读</p>\n</li>\n<li><p>Spring-AOP 核心概念以及动态代理原理</p>\n</li>\n<li><p>Spring-AOP 三大核心流程图解</p>\n</li>\n<li><p>Spring-AOP 源码阅读</p>\n</li>\n<li><p>Spring&nbsp;中的设计模式：责任链模式与反射调用</p>\n</li>\n</ul>\n<h2 id=\"02-Spring-MVC-源码\"><a href=\"#02-Spring-MVC-源码\" class=\"headerlink\" title=\"02&nbsp;Spring MVC 源码\"></a>02&nbsp;<strong>Spring MVC 源码</strong></h2><ul>\n<li><p>手写一个 Spring MVC Web 应用框架</p>\n</li>\n<li><p>Spring MVC 应用框架架构解析</p>\n</li>\n<li><p>手写一个 Spring 框架案例</p>\n</li>\n<li><p>图解 Spring MVC 执行流程</p>\n</li>\n<li><p>Spring MVC 源码阅读</p>\n</li>\n<li><p>解析 RequestMappingAdapter 流程</p>\n</li>\n</ul>\n<h2 id=\"03-Spring-Boot-应用\"><a href=\"#03-Spring-Boot-应用\" class=\"headerlink\" title=\"03&nbsp;Spring Boot 应用\"></a>03&nbsp;<strong>Spring Boot 应用</strong></h2><ul>\n<li><p>Spring Boot 与 Spring 的区别与联系</p>\n</li>\n<li><p>Spring Boot 启动流程源码解析</p>\n</li>\n<li><p>yml 配置文件加载流程解析</p>\n</li>\n<li><p>图解 Spring Boot 自动配置流程</p>\n</li>\n<li><p>Spring Boot&amp;Redis&amp;MyBatis 整合源码解析</p>\n</li>\n<li><p>使用自定义 starter 完成案例</p>\n</li>\n</ul>\n<h2 id=\"04-MyBatis-源码\"><a href=\"#04-MyBatis-源码\" class=\"headerlink\" title=\"04&nbsp;MyBatis 源码\"></a>04&nbsp;<strong>MyBatis 源码</strong></h2><ul>\n<li><p>采用面向的对象方式手写一个 MyBatis 框架</p>\n</li>\n<li><p>解析 MyBatis 版本配置文件及对应存储类分析</p>\n</li>\n<li><p>MyBatis-SqlSession 执行流程解析</p>\n</li>\n<li><p>MyBatis-Mapper 代理底层原理解析</p>\n</li>\n</ul>\n<h2 id=\"05-Tomcat-源码\"><a href=\"#05-Tomcat-源码\" class=\"headerlink\" title=\"05&nbsp;Tomcat 源码\"></a>05&nbsp;<strong>Tomcat 源码</strong></h2><ul>\n<li><p>Tomcat 底层原理解析</p>\n</li>\n<li><p>搭建 Tomcat 源码环境</p>\n</li>\n<li><p>手写 Tomcat 源码</p>\n</li>\n<li><p>阅读解析 Tomcat 启动流程</p>\n</li>\n<li><p>Tomcat 加载、创建 Servlet 流程源码解读</p>\n</li>\n<li><p>解析 Tomcat 请求处理流程</p>\n</li>\n</ul>\n<h2 id=\"06-Nginx-应用\"><a href=\"#06-Nginx-应用\" class=\"headerlink\" title=\"06&nbsp;Nginx 应用\"></a>06&nbsp;<strong>Nginx 应用</strong></h2><ul>\n<li><p>Nginx 使用原理解析</p>\n</li>\n<li><p>Web Server 技术选型</p>\n</li>\n<li><p>详解 Nginx 配置文件</p>\n</li>\n<li><p>Nginx 请求定位之 server 定位</p>\n</li>\n<li><p>Nginx 请求定位之 location 定位</p>\n</li>\n<li><p>Nginx 应用之 rewrite 重定向</p>\n</li>\n<li><p>Nginx 应用实战之静态资源服务器</p>\n</li>\n<li><p>Nginx 应用实战之反向代理应用</p>\n</li>\n<li><p>Nginx 应用实战之负载均衡</p>\n</li>\n<li><p>Nginx 应用实战之动静分离</p>\n</li>\n<li><p>Nginx 应用实战之虚拟主机应用</p>\n</li>\n<li><p>Nginx 应用实战之缓存配置</p>\n</li>\n<li><p>Nginx 应用实战之日志管理</p>\n</li>\n</ul>\n<h1 id=\"四阶段：分布式缓存-搜索专题\"><a href=\"#四阶段：分布式缓存-搜索专题\" class=\"headerlink\" title=\"四阶段：分布式缓存&amp;搜索专题\"></a>四阶段：分布式缓存&amp;搜索专题</h1><h2 id=\"01-Redis\"><a href=\"#01-Redis\" class=\"headerlink\" title=\"01&nbsp;Redis\"></a>01&nbsp;Redis</h2><ul>\n<li><p>Redis 底层数据结构的空间使用情况、时间复杂度</p>\n</li>\n<li><p>数据结构原理与场景实战</p>\n</li>\n<li><p>Redis 网络模型：阻塞&amp;非阻塞</p>\n</li>\n<li><p>用户态&amp;内核态</p>\n</li>\n<li><p>I/O 多路复用</p>\n</li>\n<li><p>Redis 单线程</p>\n</li>\n<li><p>Redis RESP 通信协议</p>\n</li>\n<li><p>Redis 的内存淘汰、内存布局、key 过期机制</p>\n</li>\n<li><p>Redis 最佳实践：key 设计原则，bigkey、hotkey 的发现方式和避免手段</p>\n</li>\n<li><p>Redis 批处理的场景和不足，分析 Redis 数据安全问题。</p>\n</li>\n<li><p>Redis 服务端优化之持久化原理和常见配置</p>\n</li>\n<li><p>Redis 服务端优化之命令安全、内存安全配置</p>\n</li>\n<li><p>Redis 运维之主从同步、哨兵、集群分片实现原理</p>\n</li>\n<li><p>Redis 场景实战</p>\n</li>\n</ul>\n<h2 id=\"02-Elasticsearch\"><a href=\"#02-Elasticsearch\" class=\"headerlink\" title=\"02&nbsp;Elasticsearch\"></a>02&nbsp;Elasticsearch</h2><ul>\n<li><p>Elasticsearch 倒排索引</p>\n</li>\n<li><p>FOR 算法、RoaringBitMap 算法原理</p>\n</li>\n<li><p>前缀树、FST 原理解析</p>\n</li>\n<li><p>Elasticsearch 之集群分片</p>\n</li>\n<li><p>Elasticsearch 全文搜索 match、精准查询 term</p>\n</li>\n<li><p>Elasticsearch 过滤器</p>\n</li>\n<li><p>Elasticsearch 组合查询、模糊查询</p>\n</li>\n<li><p>scriptings 脚本</p>\n</li>\n<li><p>Elasticsearch 分词过滤</p>\n</li>\n<li><p>Elasticsearch 文档</p>\n</li>\n<li><p>外部词库更新</p>\n</li>\n<li><p>分词器 tokenizer</p>\n</li>\n<li><p>Elasticsearch 聚合查询</p>\n</li>\n<li><p>Elasticsearch 场景实战</p>\n</li>\n</ul>\n<h1 id=\"五阶段：消息队列专题\"><a href=\"#五阶段：消息队列专题\" class=\"headerlink\" title=\"五阶段：消息队列专题\"></a>五阶段：消息队列专题</h1><h2 id=\"01-消息中间件介绍\"><a href=\"#01-消息中间件介绍\" class=\"headerlink\" title=\"01&nbsp;消息中间件介绍\"></a>01&nbsp;消息中间件介绍</h2><ul>\n<li><p>消息中间件使用场景</p>\n</li>\n<li><p>消息中间件需要解决的问题</p>\n</li>\n<li><p>消息中间件选型</p>\n</li>\n<li><p>领域模型介绍</p>\n</li>\n<li><p>RocketMQ&nbsp;环境搭建、Debug&nbsp;调试</p>\n</li>\n</ul>\n<h2 id=\"02-RocketMQ-实战\"><a href=\"#02-RocketMQ-实战\" class=\"headerlink\" title=\"02&nbsp;RocketMQ&nbsp;实战\"></a>02&nbsp;RocketMQ&nbsp;实战</h2><ul>\n<li><p>消息发送&nbsp;API&nbsp;详解与版本变迁说明</p>\n</li>\n<li><p>消息发送核心参数与工作原理</p>\n</li>\n<li><p>消息发送常见错误与解决方案</p>\n</li>\n<li><p>事务消息以及定时消息发送实战</p>\n</li>\n<li><p>消息消费&nbsp;API&nbsp;详解与版本变迁说明</p>\n</li>\n<li><p>DefaultMQPushConsumer&nbsp;核心参数与工作原理</p>\n</li>\n<li><p>DefaultMQPushConsumer&nbsp;使用示例与注意事项</p>\n</li>\n<li><p>结合应用场景学习&nbsp;DefaultMQPushConsumer</p>\n</li>\n<li><p>消息过滤实战</p>\n</li>\n<li><p>消息消费积压问题排查实战</p>\n</li>\n<li><p>订阅关系不一致实战</p>\n</li>\n<li><p>批量消费实战</p>\n</li>\n</ul>\n<h2 id=\"03-RocketMQ-原理应用\"><a href=\"#03-RocketMQ-原理应用\" class=\"headerlink\" title=\"03&nbsp;RocketMQ&nbsp;原理应用\"></a>03&nbsp;RocketMQ&nbsp;原理应用</h2><ul>\n<li><p>Broker&nbsp;启动流程分析</p>\n</li>\n<li><p>NameServer&nbsp;路由注册机制</p>\n</li>\n<li><p>生产者的发送消息流程</p>\n</li>\n<li><p>消费者的接收消息流程</p>\n</li>\n<li><p>消息的可靠性应该如何保证</p>\n</li>\n<li><p>不同消息的有序性如何解决</p>\n</li>\n<li><p>Broker&nbsp;接收消息的处理流程</p>\n</li>\n</ul>\n<h2 id=\"04-RocketMQ-高级特性\"><a href=\"#04-RocketMQ-高级特性\" class=\"headerlink\" title=\"04&nbsp;RocketMQ&nbsp;高级特性\"></a>04&nbsp;RocketMQ&nbsp;高级特性</h2><ul>\n<li><p>消息在&nbsp;Broker&nbsp;端的文件布局</p>\n</li>\n<li><p>消息存储的高效与刷盘策略</p>\n</li>\n<li><p>Broker&nbsp;快速读取消息机制</p>\n</li>\n<li><p>文件恢复与&nbsp;CheckPoint&nbsp;机制</p>\n</li>\n<li><p>消息大量堆积了该怎么办</p>\n</li>\n<li><p>部署架构与高可用机制</p>\n</li>\n<li><p>NameServer&nbsp;的设计理念</p>\n</li>\n</ul>\n<h2 id=\"05-Kafka-实战\"><a href=\"#05-Kafka-实战\" class=\"headerlink\" title=\"05&nbsp;Kafka&nbsp;实战\"></a>05&nbsp;Kafka&nbsp;实战</h2><ul>\n<li><p>Kafka&nbsp;基础架构运行流程</p>\n</li>\n<li><p>生产者选择分区发送数据流程</p>\n</li>\n<li><p>生产者发送数据的可靠性保证</p>\n</li>\n<li><p>服务端的消息处理架构模型</p>\n</li>\n<li><p>服务端消息存储的文件布局</p>\n</li>\n<li><p>如何保证服务端数据的一致性</p>\n</li>\n<li><p>消费方如何消费数据/消费分区</p>\n</li>\n<li><p>Kafka&nbsp;该如何实现顺序消费</p>\n</li>\n<li><p>消费者组重平衡流程解析</p>\n</li>\n<li><p>Kafka&nbsp;有哪些高性能的设计</p>\n</li>\n<li><p>Kafka&nbsp;与&nbsp;RocketMQ&nbsp;的主流功能对比</p>\n</li>\n</ul>\n<h1 id=\"六阶段：微服务前沿技术栈专题\"><a href=\"#六阶段：微服务前沿技术栈专题\" class=\"headerlink\" title=\"六阶段：微服务前沿技术栈专题\"></a>六阶段：微服务前沿技术栈专题</h1><h2 id=\"01-体系介绍\"><a href=\"#01-体系介绍\" class=\"headerlink\" title=\"01&nbsp;体系介绍\"></a>01&nbsp;体系介绍</h2><ul>\n<li>Nacos Registry</li>\n<li>Nacos Config</li>\n<li>OpenFeign</li>\n<li>Gateway </li>\n<li>Dubbo</li>\n<li>Sentinel</li>\n<li>Seata</li>\n</ul>\n<h2 id=\"02-Spring-Cloud-最佳实践\"><a href=\"#02-Spring-Cloud-最佳实践\" class=\"headerlink\" title=\"02 Spring Cloud 最佳实践\"></a>02 Spring Cloud 最佳实践</h2><ul>\n<li><p>Provider + Consumer + Eureka 服务搭建</p>\n</li>\n<li><p>Provider + Consumer + Nacos 服务搭建</p>\n</li>\n<li><p>Consumer + Provider + Nginx 集群搭建</p>\n</li>\n</ul>\n<h2 id=\"03-Nacos-注册与发现\"><a href=\"#03-Nacos-注册与发现\" class=\"headerlink\" title=\"03 Nacos 注册与发现\"></a>03 Nacos 注册与发现</h2><ul>\n<li><p>Nacos 服务注册案例搭建</p>\n</li>\n<li><p>Nacos 服务订阅案例搭建</p>\n</li>\n<li><p>Nacos Client 发起注册流程</p>\n</li>\n<li><p>Nacos Server 处理注册流程</p>\n</li>\n<li><p>Nacos Client 发起订阅流程</p>\n</li>\n<li><p>Nacos 心跳与剔除机制</p>\n</li>\n</ul>\n<h2 id=\"04-Nacos-配置中心\"><a href=\"#04-Nacos-配置中心\" class=\"headerlink\" title=\"04 Nacos 配置中心\"></a>04 Nacos 配置中心</h2><ul>\n<li><p>Nacos Config 动态更新端口案例搭建</p>\n</li>\n<li><p>Nacos Config 动态更新配置案例搭建</p>\n</li>\n<li><p>Nacos 配置中心源码分析</p>\n</li>\n<li><p>Nacos 动态更新机制</p>\n</li>\n<li><p>Nacos UDP 通知更新机制</p>\n</li>\n<li><p>Nacos 集群同步源码分析之 CP + AP 模式</p>\n</li>\n<li><p>Nacos 集群同步 Distro 一致性协议</p>\n</li>\n<li><p>Nacos 集群同步 Raft 一致性协议</p>\n</li>\n</ul>\n<h2 id=\"05-OpenFeign-负载均衡\"><a href=\"#05-OpenFeign-负载均衡\" class=\"headerlink\" title=\"05 OpenFeign 负载均衡\"></a>05 OpenFeign 负载均衡</h2><ul>\n<li><p>Ribbon 工程案例搭建</p>\n</li>\n<li><p>OpenFeign 负载均衡与降级案例搭建</p>\n</li>\n<li><p>OpenFeign 源码分析之 @FeignClient 注解扫描机制</p>\n</li>\n<li><p>OpenFeign 源码分析之 Feign 的上下文隔离机制</p>\n</li>\n</ul>\n<h2 id=\"06-Gateway-网关路由\"><a href=\"#06-Gateway-网关路由\" class=\"headerlink\" title=\"06 Gateway 网关路由\"></a>06 Gateway 网关路由</h2><ul>\n<li><p>Gateway 路由案例搭建</p>\n</li>\n<li><p>自定义拦截过滤</p>\n</li>\n<li><p>转发重定向机制</p>\n</li>\n</ul>\n<h2 id=\"07-Sentinel-限流降级\"><a href=\"#07-Sentinel-限流降级\" class=\"headerlink\" title=\"07 Sentinel 限流降级\"></a>07 Sentinel 限流降级</h2><ul>\n<li><p>Sentinel 手动设置限流/降级案例搭建</p>\n</li>\n<li><p>Sentinel 接入 Nacos 案例搭建</p>\n</li>\n<li><p>探索 Sentinel 规则持久化机制</p>\n</li>\n<li><p>联动 Sentinel 与 Nacos 的持久化实现</p>\n</li>\n<li><p>核心 SphU.entry 源码分析</p>\n</li>\n<li><p>ProcessorSlotChain 过滤器链流程</p>\n</li>\n<li><p>StatisticSlot 核心处理逻辑分水岭</p>\n</li>\n</ul>\n<h2 id=\"08-Dubbo-服务调用框架\"><a href=\"#08-Dubbo-服务调用框架\" class=\"headerlink\" title=\"08 Dubbo 服务调用框架\"></a>08 Dubbo 服务调用框架</h2><ul>\n<li><p>Dubbo 工程案例环境搭建</p>\n</li>\n<li><p>Provider &amp; Consumer 案例搭建</p>\n</li>\n<li><p>依赖检查 &amp; 负载均衡案例搭建</p>\n</li>\n<li><p>广播调用 &amp; 缓存操作案例搭建</p>\n</li>\n<li><p>点对点调用案例搭建</p>\n</li>\n<li><p>泛化调用案例搭建</p>\n</li>\n<li><p>Dubbo 源码分析</p>\n</li>\n<li><p>JDK SPI 与 Dubbo SPI 机制</p>\n</li>\n<li><p>Dubbo 服务发布流程</p>\n</li>\n<li><p>Dubbo 服务订阅流程</p>\n</li>\n<li><p>Dubbo Wrapper 机制</p>\n</li>\n<li><p>Dubbo 协议编解码</p>\n</li>\n</ul>\n<h1 id=\"七阶段：持续集成与容器化专题\"><a href=\"#七阶段：持续集成与容器化专题\" class=\"headerlink\" title=\"七阶段：持续集成与容器化专题\"></a>七阶段：持续集成与容器化专题</h1><h2 id=\"01-CI-CD、DevOps\"><a href=\"#01-CI-CD、DevOps\" class=\"headerlink\" title=\"01&nbsp;CI/CD、DevOps\"></a>01&nbsp;CI/CD、DevOps</h2><ul>\n<li><p>软件生命周期概念</p>\n</li>\n<li><p>CI/CD 概念</p>\n</li>\n<li><p>DevOps 概念</p>\n</li>\n<li><p>搭建实验环境</p>\n</li>\n<li><p>初识 Jenkins</p>\n</li>\n<li><p>Jekins 集成 Maven 构建 Java 应用程序</p>\n</li>\n<li><p>Jekins 集成 Git 搭建 GitLab 服务器</p>\n</li>\n<li><p>Jenkins 集成 GitLab 管理 Java 应用程序</p>\n</li>\n<li><p>Jenkins Security 用户角色管理</p>\n</li>\n<li><p>Jenkins 自动化任务</p>\n</li>\n<li><p>Jenkins 流水线 Pipeline</p>\n</li>\n<li><p>Jenkins 实战之集成 Ansible</p>\n</li>\n<li><p>Jenkins 实战之搭建 CI/CD 流水线</p>\n</li>\n</ul>\n<h2 id=\"02-Docker\"><a href=\"#02-Docker\" class=\"headerlink\" title=\"02&nbsp;Docker\"></a>02&nbsp;Docker</h2><ul>\n<li><p>Jenkins 基础&amp;安装流程</p>\n</li>\n<li><p>虚拟化技术 vs 容器化原理</p>\n</li>\n<li><p>Docker&nbsp;client 命令详解</p>\n</li>\n<li><p>Docker&nbsp;交互指令</p>\n</li>\n<li><p>Docker&nbsp;镜像概念</p>\n</li>\n<li><p>Docker&nbsp;实战部署 Web 服务</p>\n</li>\n<li><p>Docker-compose 部署多容器应用</p>\n</li>\n<li><p>Docker 进阶：container 概念详解</p>\n</li>\n<li><p>Docker 进阶：network 概念详解</p>\n</li>\n<li><p>Docker 进阶：image 概念详解</p>\n</li>\n<li><p>Docker 进阶：volume 概念详解</p>\n</li>\n<li><p>Docker Swarm：微服务项目容器化部署</p>\n</li>\n<li><p>Docker compose vs Docker Swarm</p>\n</li>\n<li><p>Docker 私服搭建</p>\n</li>\n</ul>\n<h2 id=\"03-Kubernetes\"><a href=\"#03-Kubernetes\" class=\"headerlink\" title=\"03&nbsp;Kubernetes\"></a>03&nbsp;Kubernetes</h2><ul>\n<li><p>K8s&nbsp;集群搭建</p>\n</li>\n<li><p>Harbor&nbsp;仓库搭建</p>\n</li>\n<li><p>K8s&nbsp;基本指令入门</p>\n</li>\n<li><p>K8s&nbsp;核心组件原理</p>\n</li>\n<li><p>K8s&nbsp;网络原理</p>\n</li>\n<li><p>K8s&nbsp;负载均衡</p>\n</li>\n<li><p>POD&nbsp;调度详解、重启策略</p>\n</li>\n<li><p>容器探针</p>\n</li>\n<li><p>POD&nbsp;核心原理剖析</p>\n</li>\n<li><p>Ingress&nbsp;七层负载君合实战方案</p>\n</li>\n<li><p>ReplicaSet&nbsp;剖析</p>\n</li>\n<li><p>configmap&nbsp;资源对象剖析</p>\n</li>\n<li><p>K8s&nbsp;存储解析</p>\n</li>\n<li><p>PVC&nbsp;和&nbsp;PV&nbsp;深度剖析</p>\n</li>\n<li><p>headless&nbsp;Service&nbsp;原理解析</p>\n</li>\n<li><p>statefulSet&nbsp;原理解析</p>\n</li>\n<li><p>有状态服务部署</p>\n</li>\n</ul>\n","categories":["Java","学习路线"],"tags":["Java","技术路线"]},{"title":"Java开发细节","url":"/posts/496186698.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>主要记录一些开发过程中第一次遇到的知识点，但是之后可能还会需要用到的，所以记录下来供以后查阅</p>\n<p>目前所有目录层级都用三级井号来标识，方便后期分类整理</p>\n<span id=\"more\"></span>\n\n<h3 id=\"MybatisPlusX\"><a href=\"#MybatisPlusX\" class=\"headerlink\" title=\"MybatisPlusX\"></a>MybatisPlusX</h3><ul>\n<li>首先就是可以在mapper接口上alt + enter生成xml文件，但是少了许多内容，不如直接一开始生成的时候直接生成出来，也省事，这种方法只适合补救一开始没有生成的时候的锅</li>\n<li><img src=\"/../images/img-20250709163347430.png\"></li>\n<li><img src=\"/../images/img-20250709163329120.png\"><br><strong>自动生成增删改查的方法前缀</strong></li>\n<li>自动生成查询—–写select关键字，</li>\n<li>自动生成新增—–写insert关键字</li>\n<li>自动生成修改—–写update关键字</li>\n<li>自动生成删除—–写del关键字-</li>\n</ul>\n<h3 id=\"Java基础知识点\"><a href=\"#Java基础知识点\" class=\"headerlink\" title=\"Java基础知识点\"></a>Java基础知识点</h3><ul>\n<li>Java中stream流中的map可以看成是一个转换器，把一个转换成另一个的转换器</li>\n<li>noop是指在计算机编程中的一种操作或者函数，通常用来表示一个空操作（no operation）</li>\n<li>static：<ul>\n<li>静态方法属于类本身，并非类的某个实例。因此，调用静态方法时不用先创建类的对象。这一特性在工具类的场景中十分实用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IDEA快捷键\"><a href=\"#IDEA快捷键\" class=\"headerlink\" title=\"IDEA快捷键\"></a>IDEA快捷键</h3><ul>\n<li>ctrl alt 左键 点住查看实现类</li>\n<li>CTRL P 查看参数提示</li>\n</ul>\n<h3 id=\"父子类之间的接收问题\"><a href=\"#父子类之间的接收问题\" class=\"headerlink\" title=\"父子类之间的接收问题\"></a>父子类之间的接收问题</h3><ul>\n<li><img src=\"/../images/img-20250816113423120.png\"></li>\n</ul>\n<h3 id=\"抽象类知识点\"><a href=\"#抽象类知识点\" class=\"headerlink\" title=\"抽象类知识点\"></a>抽象类知识点</h3><ul>\n<li><img src=\"/../images/img-20250816142742205.png\"></li>\n<li></li>\n</ul>\n","categories":["Java"],"tags":["Java"]},{"title":"一些打算","url":"/posts/3748947426.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>以下内容为GPT生成，后面再改</p>\n<span id=\"more\"></span>\n<h1 id=\"如何作为Java实习生不断成长\"><a href=\"#如何作为Java实习生不断成长\" class=\"headerlink\" title=\"如何作为Java实习生不断成长\"></a>如何作为Java实习生不断成长</h1><h3 id=\"📚-自我成长的具体方法与途径\"><a href=\"#📚-自我成长的具体方法与途径\" class=\"headerlink\" title=\"📚 自我成长的具体方法与途径\"></a>📚 <strong>自我成长的具体方法与途径</strong></h3><h4 id=\"1-制定学习计划\"><a href=\"#1-制定学习计划\" class=\"headerlink\" title=\"1. 制定学习计划\"></a><strong>1. 制定学习计划</strong></h4><p>学习Java的过程中，设定明确的目标和阶段性任务非常重要。</p>\n<ul>\n<li><p><strong>编程基础与算法</strong></p>\n<ul>\n<li><p>你需要掌握Java的基本语法、面向对象编程思想（OOP）、异常处理、集合框架等。</p>\n</li>\n<li><p><strong>建议书籍</strong>：</p>\n<ul>\n<li><p>《Java编程思想》：深入讲解Java的面向对象编程、线程与并发、类加载机制等。</p>\n</li>\n<li><p>《算法图解》：不局限于Java，学习数据结构和算法的基础知识。</p>\n</li>\n</ul>\n</li>\n<li><p>学习数据结构与算法是提升编程能力的基础，掌握链表、栈、队列、树、图等基本数据结构，以及排序、查找、动态规划等算法。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>设计模式与架构</strong></p>\n<ul>\n<li><p><strong>学习设计模式</strong>：掌握常见的设计模式，如单例模式、工厂模式、观察者模式等，能帮助你在项目开发中写出更加优雅和可维护的代码。</p>\n</li>\n<li><p><strong>书籍推荐</strong>：《Head First 设计模式》：图文并茂，讲解简单易懂，适合初学者。</p>\n</li>\n<li><p><strong>架构学习</strong>：掌握一些基础的系统架构设计理念，比如微服务架构、RESTful API设计、数据库设计等。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>框架与技术栈</strong></p>\n<ul>\n<li><p><strong>Spring</strong>：学习Spring框架是Java开发人员的必备技能。Spring包括Spring Core、Spring Boot、Spring MVC等，帮助你快速构建Web应用、微服务等。</p>\n</li>\n<li><p><strong>Hibernate / JPA</strong>：学习ORM框架，简化数据库操作，减少SQL编码的复杂度。</p>\n</li>\n<li><p><strong>MyBatis</strong>：另一种流行的数据库访问框架，理解它的工作原理也是很重要的。</p>\n</li>\n<li><p><strong>书籍推荐</strong>：《Spring实战》：系统学习Spring的各个组件，帮助你理解企业级开发中的应用。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>系统设计与数据库</strong></p>\n<ul>\n<li><p>学习如何设计大型系统，了解数据库优化、索引、事务、分布式等知识。</p>\n</li>\n<li><p><strong>数据库</strong>：学习关系型数据库（MySQL、PostgreSQL）和非关系型数据库（MongoDB、Redis）等技术。</p>\n</li>\n<li><p><strong>设计模式</strong>：掌握面向对象设计原则，如SOLID原则，帮助你写出可维护、可扩展的代码。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-通过实践加深理解\"><a href=\"#2-通过实践加深理解\" class=\"headerlink\" title=\"2. 通过实践加深理解\"></a><strong>2. 通过实践加深理解</strong></h4><p>在工作中，你的学习不应该仅仅停留在理论阶段。实践才是提升技能的最佳方式。</p>\n<ul>\n<li><p><strong>参与项目开发</strong></p>\n<ul>\n<li><p>在实习过程中，尽量参与到更多项目中，尤其是涉及Java核心技术栈的项目，学习如何应用理论知识解决实际问题。</p>\n</li>\n<li><p>不仅要关注前端部分，后端的系统设计、数据库设计、API开发、性能优化等都是你需要关注的重点。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>开源项目贡献</strong></p>\n<ul>\n<li><p>在GitHub上寻找开源项目并做贡献，不仅能提高你的编程技能，还能拓展人脉，提升你的职业形象。</p>\n</li>\n<li><p><strong>如何做贡献</strong>：从修复bug、增加文档、优化代码开始，逐步积累经验。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>编写博客或技术笔记</strong></p>\n<ul>\n<li><p>写博客或技术笔记能够帮助你总结和巩固学习的内容。同时，你的分享也能帮助他人。</p>\n</li>\n<li><p><strong>平台推荐</strong>：掘金、知乎、CSDN等。</p>\n</li>\n<li><p>你可以将每天的学习笔记、解决的技术难题或者项目经验分享出来，帮助自己梳理思路，也能为未来的职业发展积累影响力。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-学习方法\"><a href=\"#3-学习方法\" class=\"headerlink\" title=\"3. 学习方法\"></a><strong>3. 学习方法</strong></h4><ul>\n<li><p><strong>边做边学</strong></p>\n<ul>\n<li><p>理论和实践是相辅相成的，通过做项目来加深理解，遇到问题时再去查资料、看书，解决实际问题。</p>\n</li>\n<li><p>每完成一个模块，都会学到新的东西，特别是从解决实际问题中，你会获得更深刻的经验。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>看书与读文档</strong></p>\n<ul>\n<li><p><strong>阅读书籍</strong>：技术书籍通常比网络文章更加系统、深入。可以选择经典书籍逐步精进，推荐《Effective Java》、《Java并发编程实战》。</p>\n</li>\n<li><p><strong>查阅官方文档</strong>：大多数开源框架和工具都有官方文档，学习官方文档能让你了解技术的最佳实践，避免误用。</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"📝-定期复盘与自我评估\"><a href=\"#📝-定期复盘与自我评估\" class=\"headerlink\" title=\"📝 定期复盘与自我评估\"></a>📝 <strong>定期复盘与自我评估</strong></h3><h4 id=\"1-定期复盘\"><a href=\"#1-定期复盘\" class=\"headerlink\" title=\"1. 定期复盘\"></a><strong>1. 定期复盘</strong></h4><ul>\n<li><p><strong>每周复盘</strong></p>\n<ul>\n<li><p>每周结束时，花20-30分钟回顾一周的学习与工作，看看自己取得了哪些进展，遇到了哪些难题，哪些地方可以改进。</p>\n</li>\n<li><p>可以列出一周完成的任务清单和未完成的任务，找出问题并总结经验。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>每月复盘</strong></p>\n<ul>\n<li><p>每个月初进行一次全面复盘，回顾自己这一月的学习进度，调整自己的目标。</p>\n</li>\n<li><p>评估自己在技术深度、项目经验、编程能力等方面的提升，并设定下个月的目标。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-定期自我评估\"><a href=\"#2-定期自我评估\" class=\"headerlink\" title=\"2. 定期自我评估\"></a><strong>2. 定期自我评估</strong></h4><ul>\n<li><p><strong>代码质量</strong></p>\n<ul>\n<li><p>定期检查自己写的代码，分析其可读性、可维护性、性能等。</p>\n</li>\n<li><p>通过重构、单元测试等方法提高代码质量。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>技术深度</strong></p>\n<ul>\n<li>评估自己掌握的技术深度，看看哪些领域还没有深入学习，例如并发编程、分布式系统、云计算等。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"📖-上班期间如何看书\"><a href=\"#📖-上班期间如何看书\" class=\"headerlink\" title=\"📖 上班期间如何看书\"></a>📖 <strong>上班期间如何看书</strong></h3><h4 id=\"1-利用通勤时间\"><a href=\"#1-利用通勤时间\" class=\"headerlink\" title=\"1. 利用通勤时间\"></a><strong>1. 利用通勤时间</strong></h4><p>如果你每天需要通勤，可以利用这个时间听技术类播客或技术书籍的有声版，帮助你充分利用碎片时间。</p>\n<h4 id=\"2-在午休时间阅读\"><a href=\"#2-在午休时间阅读\" class=\"headerlink\" title=\"2. 在午休时间阅读\"></a><strong>2. 在午休时间阅读</strong></h4><p>午休时间是一个较为集中的阅读时间，你可以在这段时间里看书或整理学习笔记。</p>\n<h4 id=\"3-晚上坚持读书\"><a href=\"#3-晚上坚持读书\" class=\"headerlink\" title=\"3. 晚上坚持读书\"></a><strong>3. 晚上坚持读书</strong></h4><p>每天晚上安排30分钟到1小时的阅读时间，专注于深度的技术书籍或者专业文献，积累知识。</p>\n<h4 id=\"4-阅读技巧\"><a href=\"#4-阅读技巧\" class=\"headerlink\" title=\"4. 阅读技巧\"></a><strong>4. 阅读技巧</strong></h4><ul>\n<li><p><strong>做好笔记</strong>：在读书时，随时做笔记，将重要的概念和技巧记录下来。</p>\n</li>\n<li><p><strong>思考与实践</strong>：读完书后，尽量将书中的理论与实际工作结合，思考如何在自己的工作中应用。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"💼-兼职建议来补贴生活费用\"><a href=\"#💼-兼职建议来补贴生活费用\" class=\"headerlink\" title=\"💼 兼职建议来补贴生活费用\"></a>💼 <strong>兼职建议来补贴生活费用</strong></h3><h4 id=\"1-线上编程兼职\"><a href=\"#1-线上编程兼职\" class=\"headerlink\" title=\"1. 线上编程兼职\"></a><strong>1. 线上编程兼职</strong></h4><ul>\n<li><p><strong>平台</strong>：你可以在一些兼职平台上找到编程任务，如Freelancer、Upwork、猪八戒等。</p>\n</li>\n<li><p><strong>项目类型</strong>：你可以选择一些小型的Java开发项目，如开发API、网站后台、自动化脚本等。</p>\n</li>\n</ul>\n<h4 id=\"2-教学或辅导\"><a href=\"#2-教学或辅导\" class=\"headerlink\" title=\"2. 教学或辅导\"></a><strong>2. 教学或辅导</strong></h4><ul>\n<li><p><strong>编程辅导</strong>：如果你擅长Java，可以做线上或线下的编程辅导，帮助他人学习Java。</p>\n</li>\n<li><p><strong>辅导学生</strong>：许多学生需要学习Java，你可以通过线上平台提供编程辅导服务。</p>\n</li>\n</ul>\n<h4 id=\"3-技术博客或写作\"><a href=\"#3-技术博客或写作\" class=\"headerlink\" title=\"3. 技术博客或写作\"></a><strong>3. 技术博客或写作</strong></h4><ul>\n<li><p><strong>写技术博客</strong>：你可以在技术博客平台上发布技术文章，很多平台会根据你的阅读量支付稿费。</p>\n</li>\n<li><p><strong>编写教程或电子书</strong>：你可以将自己的学习经验或项目经验写成教程，出售或共享给别人。</p>\n</li>\n</ul>\n<h4 id=\"4-做小型项目或工具\"><a href=\"#4-做小型项目或工具\" class=\"headerlink\" title=\"4. 做小型项目或工具\"></a><strong>4. 做小型项目或工具</strong></h4><ul>\n<li><p><strong>开发工具</strong>：你可以开发一些简单的Java工具、网站、或者自动化脚本，出售或出租这些工具给需要的用户。</p>\n</li>\n<li><p><strong>开源项目</strong>：有些开源项目会提供资助，或者你可以在贡献代码的同时获得雇佣机会。</p>\n</li>\n</ul>\n","categories":["计划"],"tags":["Planning","Java"]},{"title":"Java学习笔记","url":"/posts/2072697129.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>对Java进行查漏补缺</p>\n<span id=\"more\"></span>\n<p><img src=\"/../images/img-20250706151045512.png\"></p>\n<ul>\n<li>JIT编译器运行之后把字节码对应的机器码保存下来下次用<img src=\"/../images/img-20250706151331722.png\"><br>  <img src=\"/../images/img-20250706151519878.png\"></li>\n<li>编译和解释型<ul>\n<li>编译型：把源代码翻译成机器码，开发效率慢，执行速度快。常见的编译性语言有 C、C++、Go、Rust</li>\n<li>解释型：一句一句把代码解释成机器代码再执行，开发效率快，执行速度慢。常见的解释性语言有 Python、JavaScript、PHP</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><hr>\n<h3 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h3><ul>\n<li>使用条件：只有一个抽象方法的匿名内部类（匿名内部类是一个接口，并且这个接口里面只有一个抽象方法需要重写）</li>\n<li>内部类方法优化成lambda表达式方法：内部类方法中把括号和方法体部分剪切下来，把内部类整个都删了然后粘贴刚刚复制的括号和方法体，在括号和方法之间加一个向右的箭头</li>\n<li><img src=\"/../images/img-20250710161626447.png\"></li>\n<li><strong>将内部类写法变成lambda表达式写法</strong>  点击内部类然后快捷键 alt enter</li>\n<li><img src=\"/../images/img-20250710165350053.png\"></li>\n<li><strong>把lambda表达式转换成原来内部类的写法</strong></li>\n<li><img src=\"/../images/img-20250710165708229.png\"></li>\n<li></li>\n</ul>\n","categories":["Java","笔记"],"tags":["Java"]},{"title":"Java知识手册","url":"/posts/1289796624.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>此处放一些个人收藏的技术网站，等待以后有时间自己沉淀技术博客文章</p>\n<span id=\"more\"></span>\n\n<p><strong><a href=\"https://www.yuque.com/tulingzhouyu/db22bv/dwrlxcihwh7r3grg\">一万字Java面经</a></strong></p>\n<p><strong><a href=\"https://www.wdbyte.com/\">未读代码</a></strong></p>\n<p><strong><a href=\"https://www.yuque.com/vip6688/neho4x\">Java八股文</a></strong></p>\n<p><strong><a href=\"https://liaoxuefeng.com/books/java/introduction/index.html\">廖雪峰官方网站</a></strong></p>\n<p><strong><a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg4MjU0OTM1OA==&amp;action=getalbum&amp;album_id=1664731708878848004&amp;scene=21#wechat_redirect\">精通JVM系列</a></strong></p>\n<p><strong><a href=\"https://www.cnkirito.moe/categories/\">徐靖峰|个人博客</a></strong></p>\n","categories":["Java"],"tags":["Java","面试","八股文"]},{"title":"Linux","url":"/posts/1406167115.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>Linux有关知识点</p>\n<span id=\"more\"></span>\n\n<h3 id=\"目录结构说明\"><a href=\"#目录结构说明\" class=\"headerlink\" title=\"目录结构说明\"></a>目录结构说明</h3><hr>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">/  # 根目录（所有目录的起点）<br>├── bin/            # 基础命令（ls、cp 等，所有用户可执行）<br>├── sbin/           # 系统管理命令（reboot、ifconfig 等，root 专用）<br>├── usr/            # 用户程序和数据（类似 Windows 的 Program Files）<br>│   ├── bin/        # 非启动必需的用户命令（如 wget、vim）<br>│   ├── sbin/       # 非启动必需的系统命令<br>│   ├── lib/        # 程序依赖的库文件<br>│   ├── lib64/      # 64位程序的库文件<br>│   └── share/      # 共享数据（文档、语言包等）<br>├── etc/            # 系统配置文件（服务配置、用户信息等）<br>│   ├── sysconfig/  # 系统服务配置（网络、防火墙等）<br>│   ├── nginx/      # Nginx 服务配置（示例）<br>│   └── passwd      # 用户账号信息<br>├── var/            # 动态变化的文件（日志、缓存等）<br>│   ├── log/        # 系统和程序日志（如 /var/log/messages）<br>│   ├── lib/        # 服务运行数据（如数据库文件）<br>│   └── tmp/        # 服务临时文件<br>├── tmp/            # 临时文件（重启后清空）<br>├── boot/           # 启动文件（内核、grub 引导程序）<br>├── dev/            # 设备文件（硬盘、终端等，如 /dev/sda）<br>├── proc/           # 虚拟文件系统（实时进程、内存信息等）<br>├── sys/            # 虚拟文件系统（硬件设备管理）<br>├── lib/            # 系统共享库（类似 .dll 文件）<br>├── lib64/          # 64位系统共享库<br>├── mnt/            # 临时挂载外部设备（U盘、移动硬盘）<br>├── media/          # 自动挂载的外部设备（如光盘）<br>├── opt/            # 第三方软件安装目录（如 /opt/redis）<br>└── home/           # 普通用户家目录<br>    ├── user1/      # 用户 user1 的家目录（等价于 ~）<br>    └── user2/      # 用户 user2 的家目录<br>└── root/           # root 用户的家目录（等价于 ~，root 专属）<br></code></pre></td></tr></tbody></table></figure>\n","categories":["操作系统"],"tags":["Linux"]},{"title":"MySQL","url":"/posts/3259397556.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><img src=\"/images/file-20241023133230490.png\"></p>\n<p><strong>MySQL相关知识总结</strong></p>\n<span id=\"more\"></span>\n<h1 id=\"如何处理-mysql-的死锁问题\"><a href=\"#如何处理-mysql-的死锁问题\" class=\"headerlink\" title=\"如何处理 mysql 的死锁问题\"></a>如何处理 mysql 的死锁问题</h1><p><a href=\"https://xie.infoq.cn/article/71b956f9467eddb8c352bada1\"># 如何处理 mysql 的死锁问题</a></p>\n","categories":["数据库","MySQL"],"tags":["MySQL","数据库"]},{"title":"Plans For Shopping","url":"/posts/66236015.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>费钱计划</p>\n<span id=\"more\"></span>\n<p><del>1. 铭凡um790Pro （16+1T）</del><br><del>2. 显示器</del><br><del>3. 键鼠套装</del><br><del>4. 读卡器</del><br>5. 闪迪内存卡256G<br><del>6. 佳能R10</del> 这个没买，镜头太贵，改买尼康Z50II了，加了一个16-50的唯卓士的z口镜头<br><del>7. 50mm小痰盂</del><br><del>8.小喇叭</del><br>~~9.</p>\n","categories":["计划","购物"],"tags":["购物","相机","电脑"]},{"title":"Plans for 2025","url":"/posts/3838745332.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>2025年升级清单(制定的有些晚)</p>\n<span id=\"more\"></span>\n<h1 id=\"五月\"><a href=\"#五月\" class=\"headerlink\" title=\"五月\"></a>五月</h1><hr>\n<ol>\n<li>学会React基础知识   </li>\n<li></li>\n</ol>\n","categories":["年度"],"tags":["年度期待","Planning"]},{"title":"React博客学习笔记","url":"/posts/2317628258.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>React博客学习笔记</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p><img src=\"/../images/img-20250606223050730.png\"></p>\n<p>  如果你遇到以下情况，建议使用 getPopupContainer：<br>  下拉菜单被截断或无法完整显示<br>  使用了 CSS transform, filter, clip-path 等影响定位的属性<br>  使用了 position: fixed 或响应式布局，需要控制层级关系</p>\n</li>\n<li></li>\n</ul>\n","categories":["笔记"],"tags":["React","项目笔记"]},{"title":"Python学习笔记","url":"/posts/695896537.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>记录Python学习过程中的知识点</p>\n<span id=\"more\"></span>\n\n<h3 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728203450937.png\"></li>\n</ul>\n<h3 id=\"第一个Python程序\"><a href=\"#第一个Python程序\" class=\"headerlink\" title=\"第一个Python程序\"></a>第一个Python程序</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728204149769.png\"></li>\n</ul>\n<h3 id=\"PyCharm-的初始设置\"><a href=\"#PyCharm-的初始设置\" class=\"headerlink\" title=\"PyCharm 的初始设置\"></a>PyCharm 的初始设置</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728204359931.png\"></li>\n<li>设置编译版本</li>\n<li><img src=\"/../images/img-20250730180937183.png\"></li>\n</ul>\n<h3 id=\"多文件项目的演练\"><a href=\"#多文件项目的演练\" class=\"headerlink\" title=\"多文件项目的演练\"></a>多文件项目的演练</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728204839288.png\"></li>\n</ul>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728204942230.png\"></li>\n</ul>\n<h3 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205004705.png\"></li>\n<li><strong>主要</strong>：</li>\n<li><img src=\"/../images/img-20250730183827808.png\"></li>\n</ul>\n<h3 id=\"程序执行原理\"><a href=\"#程序执行原理\" class=\"headerlink\" title=\"程序执行原理\"></a>程序执行原理</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205036190.png\"></li>\n</ul>\n<h3 id=\"变量的基本使用\"><a href=\"#变量的基本使用\" class=\"headerlink\" title=\"变量的基本使用\"></a>变量的基本使用</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205114651.png\"></li>\n</ul>\n<h3 id=\"变量的命名\"><a href=\"#变量的命名\" class=\"headerlink\" title=\"变量的命名\"></a>变量的命名</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205141245.png\"></li>\n</ul>\n<h3 id=\"判断（if）语句\"><a href=\"#判断（if）语句\" class=\"headerlink\" title=\"判断（if）语句\"></a>判断（if）语句</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205213363.png\"></li>\n</ul>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205239630.png\"></li>\n</ul>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205308924.png\"></li>\n</ul>\n<h3 id=\"函数基础\"><a href=\"#函数基础\" class=\"headerlink\" title=\"函数基础\"></a>函数基础</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205439581.png\"></li>\n</ul>\n<h3 id=\"高级变量类型\"><a href=\"#高级变量类型\" class=\"headerlink\" title=\"高级变量类型\"></a>高级变量类型</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205515392.png\"></li>\n<li><img src=\"/../images/img-20250728205552587.png\"></li>\n</ul>\n<h3 id=\"综合应用–名片管理系统\"><a href=\"#综合应用–名片管理系统\" class=\"headerlink\" title=\"综合应用–名片管理系统\"></a>综合应用–名片管理系统</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205630375.png\"></li>\n</ul>\n<h3 id=\"变量进阶\"><a href=\"#变量进阶\" class=\"headerlink\" title=\"变量进阶\"></a>变量进阶</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205700268.png\"></li>\n</ul>\n<h3 id=\"函数进阶\"><a href=\"#函数进阶\" class=\"headerlink\" title=\"函数进阶\"></a>函数进阶</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250728205729553.png\"></li>\n</ul>\n","categories":["Python"],"tags":["Python","学习笔记"]},{"title":"Redis","url":"/posts/3135569683.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>Redis学习记录</p>\n<ul>\n<li><a href=\"https://redis.io/docs/latest/commands/\">Redis官方文档</a><span id=\"more\"></span></li>\n</ul>\n<h3 id=\"Sql与Nosql区别\"><a href=\"#Sql与Nosql区别\" class=\"headerlink\" title=\"Sql与Nosql区别\"></a>Sql与Nosql区别</h3><ul>\n<li><img src=\"/../images/img-20250712101415422.png\"></li>\n<li><img src=\"/../images/img-20250712101506072.png\"></li>\n</ul>\n<h3 id=\"Redis简介\"><a href=\"#Redis简介\" class=\"headerlink\" title=\"Redis简介\"></a>Redis简介</h3><ul>\n<li><img src=\"/../images/img-20250712102231830.png\"></li>\n</ul>\n<h3 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装redis</h3><ul>\n<li>如何看redis是否已经运行  <ul>\n<li>ps -ef | grep redis</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Redis的value类型\"><a href=\"#Redis的value类型\" class=\"headerlink\" title=\"Redis的value类型\"></a>Redis的value类型</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250712153158316.png\"><br>帮助：在redis-cli中输：<code>help @</code>   然后按tab键进行切换</li>\n</ul>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250712155638415.png\"></li>\n<li>过期时间中 -1是永久存在，-2是已经到期</li>\n</ul>\n<h3 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250712155847615.png\"></li>\n<li>常见命令<img src=\"/../images/img-20250712155910384.png\"><ul>\n<li>incrbyfloat没有默认增长，后面必须要加增长多少，没有默认增长</li>\n<li>setNx是新增不存在的<ul>\n<li><code>set name zhangsan nx</code>和<code>setNx name zhangsan</code>效果是一样的</li>\n</ul>\n</li>\n<li>setEx<ul>\n<li><code>setex name 10 Jack</code>跟<code>set name Jack  ex 19</code>效果是一样的</li>\n</ul>\n</li>\n<li>DEL 删除，并且可以批量删除</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Key的结构\"><a href=\"#Key的结构\" class=\"headerlink\" title=\"Key的结构\"></a>Key的结构</h4><hr>\n<ul>\n<li><img src=\"/../images/img-20250712161619523.png\"></li>\n<li><img src=\"/../images/img-20250712161658256.png\"></li>\n</ul>\n<h3 id=\"Hash类型\"><a href=\"#Hash类型\" class=\"headerlink\" title=\"Hash类型\"></a>Hash类型</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250712162223357.png\"></li>\n<li><img src=\"/../images/img-20250712162248829.png\"></li>\n<li>HMset：set的时候可以把键放在前面，然后面直接就是多个kv kv kv</li>\n<li>HMget：get的时候可以把所有的键写下来，k k k k </li>\n<li>HgetALL：直接写顶级的，一级key，就能把所有的子集数据展示出来</li>\n<li>HsetNx：是判断field存不存在，不是顶级key了</li>\n</ul>\n<h3 id=\"List类型\"><a href=\"#List类型\" class=\"headerlink\" title=\"List类型\"></a>List类型</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250712164102165.png\"></li>\n<li>BLPOP中的B是block，阻塞的意思</li>\n<li><img src=\"/../images/img-20250712164821403.png\"></li>\n<li><img src=\"/../images/img-20250712164541380.png\"></li>\n<li>BLPOP的语法是 BLPOP  [key]  [timeout]，就是如果找不到就一直阻塞在那边，如果在阻塞的同时添加一个键进去，那边阻塞立马就会结束并且返回键中的最L值，同理BRPOP也是如此</li>\n</ul>\n<h3 id=\"Set类型\"><a href=\"#Set类型\" class=\"headerlink\" title=\"Set类型\"></a>Set类型</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250713100649155.png\"></li>\n<li><img src=\"/../images/img-20250713100944165.png\"></li>\n</ul>\n<h3 id=\"SortedSet类型\"><a href=\"#SortedSet类型\" class=\"headerlink\" title=\"SortedSet类型\"></a>SortedSet类型</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250713102147526.png\"></li>\n<li><img src=\"/../images/img-20250713102505120.png\"></li>\n<li>默认升序，ZRank是升序，ZREVRank是降序，加REV是直接在Z后面加的，REV指的是reverse（反转）</li>\n<li>zcount是针对<strong>分数</strong>score的，zrange是针对<strong>排名</strong>的范围，count是查数量，range是查元素，查人名的</li>\n</ul>\n<h3 id=\"Redis的Java客户端\"><a href=\"#Redis的Java客户端\" class=\"headerlink\" title=\"Redis的Java客户端\"></a>Redis的Java客户端</h3><hr>\n<ul>\n<li>Redis的Java客户端</li>\n<li><img src=\"/../images/img-20250713105935049.png\"></li>\n</ul>\n<h3 id=\"Jedis\"><a href=\"#Jedis\" class=\"headerlink\" title=\"Jedis\"></a>Jedis</h3><hr>\n<ul>\n<li>jedis中方法名和redis是一致的</li>\n<li><img src=\"/../images/img-20250713113838932.png\"><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JedisTest</span> {  <br>    <span class=\"hljs-keyword\">private</span> Jedis jedis;  <br>  <br>  <br>    <span class=\"hljs-meta\">@BeforeEach</span>  <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setup</span><span class=\"hljs-params\">()</span>{  <br>        <span class=\"hljs-comment\">//连接  </span><br>        jedis = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Jedis</span>(<span class=\"hljs-string\">\"ip\"</span>,<span class=\"hljs-number\">6379</span>);  <br>        <span class=\"hljs-comment\">//密码  </span><br>        jedis.auth(<span class=\"hljs-string\">\"redis\"</span>);  <br>        <span class=\"hljs-comment\">//选择库  </span><br>        jedis.select(<span class=\"hljs-number\">1</span>);  <br>    }  <br>  <br>    <span class=\"hljs-meta\">@Test</span>  <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testString</span><span class=\"hljs-params\">()</span>{  <br>        <span class=\"hljs-comment\">// 存  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">set</span> <span class=\"hljs-operator\">=</span> jedis.set(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"Odyssey\"</span>);  <br>        System.out.println(<span class=\"hljs-string\">\"set = \"</span>+set);  <br>        <span class=\"hljs-comment\">// 取  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> jedis.get(<span class=\"hljs-string\">\"name\"</span>);  <br>        System.out.println(<span class=\"hljs-string\">\"name = \"</span>+name);  <br>    }  <br>  <br>    <span class=\"hljs-meta\">@Test</span>  <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testHash</span><span class=\"hljs-params\">()</span>{  <br>        jedis.hset(<span class=\"hljs-string\">\"user:1\"</span>, <span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"Odyssey\"</span>);  <br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> jedis.hget(<span class=\"hljs-string\">\"user:1\"</span>, <span class=\"hljs-string\">\"name\"</span>);  <br>        System.out.println(<span class=\"hljs-string\">\"name = \"</span>+name);  <br>        HashMap&lt;String, String&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();  <br>        map.put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"Odyssey\"</span>);  <br>        map.put(<span class=\"hljs-string\">\"age\"</span>, <span class=\"hljs-string\">\"18\"</span>);  <br>        map.put(<span class=\"hljs-string\">\"sex\"</span>, <span class=\"hljs-string\">\"男\"</span>);  <br>        map.put(<span class=\"hljs-string\">\"address\"</span>, <span class=\"hljs-string\">\"中国\"</span>);  <br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">hmset</span> <span class=\"hljs-operator\">=</span> jedis.hmset(<span class=\"hljs-string\">\"user:1\"</span>, map);  <br>        System.out.println(<span class=\"hljs-string\">\"hmset = \"</span>+hmset);  <br>        Map&lt;String, String&gt; stringStringMap = jedis.hgetAll(<span class=\"hljs-string\">\"user:1\"</span>);  <br>        System.out.println(<span class=\"hljs-string\">\"stringStringMap = \"</span>+stringStringMap);  <br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">age</span> <span class=\"hljs-operator\">=</span> jedis.hget(<span class=\"hljs-string\">\"user:1\"</span>, <span class=\"hljs-string\">\"age\"</span>);  <br>        System.out.println(<span class=\"hljs-string\">\"age = \"</span>+age);  <br>    }  <br>  <br>    <span class=\"hljs-meta\">@AfterEach</span>  <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">close</span><span class=\"hljs-params\">()</span>{  <br>        <span class=\"hljs-keyword\">if</span>(jedis!=<span class=\"hljs-literal\">null</span>){  <br>            jedis.close();  <br>        }  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h3 id=\"Jedis连接池\"><a href=\"#Jedis连接池\" class=\"headerlink\" title=\"Jedis连接池\"></a>Jedis连接池</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250713113959889.png\"><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JedisConnectionFactory</span> {  <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> JedisPool jedisPool;  <br>  <br>    <span class=\"hljs-comment\">/*  </span><br><span class=\"hljs-comment\">    执行机制：静态代码块会在类被加载的时候自动执行，  </span><br><span class=\"hljs-comment\">    而且仅执行一次，这确保了连接池会在应用启动时就完成初始化  </span><br><span class=\"hljs-comment\">     */</span>    <span class=\"hljs-keyword\">static</span> {  <br>        <span class=\"hljs-comment\">//配置连接池  </span><br>        <span class=\"hljs-type\">JedisPoolConfig</span> <span class=\"hljs-variable\">poolConfig</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JedisPoolConfig</span>();  <br>        <span class=\"hljs-comment\">//最大连接数  </span><br>        poolConfig.setMaxTotal(<span class=\"hljs-number\">8</span>);  <br>        <span class=\"hljs-comment\">//最大空闲连接数  </span><br>        poolConfig.setMaxIdle(<span class=\"hljs-number\">8</span>);  <br>        <span class=\"hljs-comment\">// 最小空闲连接数  </span><br>        poolConfig.setMinIdle(<span class=\"hljs-number\">0</span>);  <br>        <span class=\"hljs-comment\">// 获取连接时的最大等待毫秒  </span><br>        poolConfig.setMaxWaitMillis(<span class=\"hljs-number\">1000</span>);  <br>        <span class=\"hljs-comment\">// 创建连接池对象  </span><br>        jedisPool = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JedisPool</span>(poolConfig, <span class=\"hljs-string\">\"ip/hostname\"</span>, <span class=\"hljs-number\">6379</span>, <span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">\"pwd\"</span>);  <br>    }  <br>  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Jedis <span class=\"hljs-title function_\">getJedis</span><span class=\"hljs-params\">()</span> {  <br>        <span class=\"hljs-keyword\">return</span> jedisPool.getResource();  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h3 id=\"SpringDataRedis\"><a href=\"#SpringDataRedis\" class=\"headerlink\" title=\"SpringDataRedis\"></a>SpringDataRedis</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250713134144625.png\"></li>\n<li><img src=\"/../images/img-20250713134512867.png\"><br><strong>快速入门</strong></li>\n</ul>\n<ol>\n<li>引入依赖（access+driver）<img src=\"/../images/img-20250713140550237.png\"></li>\n<li>编写application.yml配置<img src=\"/../images/img-20250713135537882.png\"></li>\n<li>注入RedisTemplate</li>\n</ol>\n<h3 id=\"SpringRedisData序列化方式\"><a href=\"#SpringRedisData序列化方式\" class=\"headerlink\" title=\"SpringRedisData序列化方式\"></a>SpringRedisData序列化方式</h3><hr>\n<ul>\n<li><p><img src=\"/../images/img-20250713141101550.png\"></p>\n</li>\n<li><p>key和HashKey使用RedisSerializer</p>\n</li>\n<li><p>value的序列化一般采用GenericJackson2JsonRedisSerializer来序列化</p>\n</li>\n<li><p>如果没有引入springmvc或者springweb依赖注意要加一个jackson-databind；</p>\n</li>\n<li><p>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p>\n</li>\n<li><p><img src=\"/../images/img-20250713151851315.png\"></p>\n</li>\n</ul>\n<h3 id=\"StringRedisTemplate\"><a href=\"#StringRedisTemplate\" class=\"headerlink\" title=\"StringRedisTemplate\"></a>StringRedisTemplate</h3><hr>\n<ul>\n<li><img src=\"/../images/img-20250713151959972.png\"></li>\n<li>ObjectMapper是用SpringMVC中自带的序列化工具，也可以用FastJSON</li>\n<li>现在保存到数据库之前要手动序列化，然后读取的时候要手动的反序列化<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Autowired</span>  <br><span class=\"hljs-keyword\">private</span> StringRedisTemplate stringRedisTemplate;<br><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">ObjectMapper</span> <span class=\"hljs-variable\">objectMapper</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectMapper</span>();<br><br>    <span class=\"hljs-meta\">@Test</span>  <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSaveUser</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> JsonProcessingException {  <br>        <span class=\"hljs-comment\">// 写入  </span><br><span class=\"hljs-comment\">//        redisTemplate.opsForValue().set(\"user\",new User(\"OdysseyChan\",17));  </span><br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">u</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-string\">\"张三\"</span>, <span class=\"hljs-number\">17</span>);  <br>        <span class=\"hljs-comment\">// 手动序列化  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">json</span> <span class=\"hljs-operator\">=</span> objectMapper.writeValueAsString(u);  <br>        stringRedisTemplate.opsForValue().set(<span class=\"hljs-string\">\"user:200\"</span>,json);  <br>        <span class=\"hljs-comment\">// 获取数据  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">jsonUser</span> <span class=\"hljs-operator\">=</span> stringRedisTemplate.opsForValue().get(<span class=\"hljs-string\">\"user:200\"</span>);  <br>        <span class=\"hljs-comment\">// 手动反序列化  </span><br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> objectMapper.readValue(jsonUser, User.class);  <br>        System.out.println(<span class=\"hljs-string\">\"user = \"</span> + user);  <br>    }<br></code></pre></td></tr></tbody></table></figure></li>\n<li>整个测试类<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@SpringBootTest</span>  <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RedisDemoApplicationTests</span> {  <br>  <br>    <span class=\"hljs-meta\">@Autowired</span>  <br>    <span class=\"hljs-keyword\">private</span> RedisTemplate redisTemplate;  <br>    <span class=\"hljs-meta\">@Autowired</span>  <br>    <span class=\"hljs-keyword\">private</span> StringRedisTemplate stringRedisTemplate;  <br>  <br>    <span class=\"hljs-meta\">@Test</span>  <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testRedisTemplate</span><span class=\"hljs-params\">()</span> {  <br>        <span class=\"hljs-comment\">//写入  </span><br>        redisTemplate.opsForValue().set(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"OdysseyChan\"</span>);  <br>        <span class=\"hljs-comment\">//读取  </span><br>        <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">name</span> <span class=\"hljs-operator\">=</span> redisTemplate.opsForValue().get(<span class=\"hljs-string\">\"name\"</span>);  <br>        System.out.println(<span class=\"hljs-string\">\"name = \"</span> + name);  <br>    }  <br>  <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">ObjectMapper</span> <span class=\"hljs-variable\">objectMapper</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ObjectMapper</span>();  <br>  <br>    <span class=\"hljs-meta\">@Test</span>  <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSaveUser</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> JsonProcessingException {  <br>        <span class=\"hljs-comment\">// 写入  </span><br><span class=\"hljs-comment\">//        redisTemplate.opsForValue().set(\"user\",new User(\"OdysseyChan\",17));  </span><br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">u</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-string\">\"张三\"</span>, <span class=\"hljs-number\">17</span>);  <br>        <span class=\"hljs-comment\">// 手动序列化  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">json</span> <span class=\"hljs-operator\">=</span> objectMapper.writeValueAsString(u);  <br>        stringRedisTemplate.opsForValue().set(<span class=\"hljs-string\">\"user:200\"</span>, json);  <br>        <span class=\"hljs-comment\">// 获取数据  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">jsonUser</span> <span class=\"hljs-operator\">=</span> stringRedisTemplate.opsForValue().get(<span class=\"hljs-string\">\"user:200\"</span>);  <br>        <span class=\"hljs-comment\">// 手动反序列化  </span><br>        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> objectMapper.readValue(jsonUser, User.class);  <br>        System.out.println(<span class=\"hljs-string\">\"user = \"</span> + user);  <br>    }  <br>  <br>    <span class=\"hljs-meta\">@Test</span>  <br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testHash</span><span class=\"hljs-params\">()</span> {  <br>        stringRedisTemplate.opsForHash().put(<span class=\"hljs-string\">\"user:300\"</span>, <span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"刘能\"</span>);  <br>        stringRedisTemplate.opsForHash().put(<span class=\"hljs-string\">\"user:300\"</span>, <span class=\"hljs-string\">\"age\"</span>, <span class=\"hljs-string\">\"18\"</span>);  <br>  <br>        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class=\"hljs-string\">\"user:300\"</span>);  <br>        System.out.println(<span class=\"hljs-string\">\"entries = \"</span> + entries);  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><hr>\n<p>目前Redis这里先是从redis的基础语法包括String 、Hash、List、Set、SortedSet，学习了解如何存取并且设置存活时间，接着学习在Java项目中使用jedis和lettuce进行操作存取，然后学习了使用jedis连接池来获取jedis对象，最后使用SpringDataRedis来进行操作redis，其中包括为避免序列中存储的额外开销而使用StringRedisTemplate</p>\n","categories":["数据库"],"tags":["数据库","Redis"]},{"title":"Spring Security学习","url":"/posts/122562275.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>记录安全框架Spring Security学习</p>\n<span id=\"more\"></span>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h2 id=\"登录校验流程\"><a href=\"#登录校验流程\" class=\"headerlink\" title=\"登录校验流程\"></a>登录校验流程</h2><p><img src=\"/../images/img-20250706143637159.png\"></p>\n<h2 id=\"完整流程\"><a href=\"#完整流程\" class=\"headerlink\" title=\"完整流程\"></a>完整流程</h2><p><img src=\"/../images/img-20250706144651107.png\"><br>三个过滤器分别是：认证，异常处理，授权</p>\n<ul>\n<li>认证流程</li>\n<li><img src=\"/../images/img-20250710155343440.png\"></li>\n<li>登录验证时序图<br><img src=\"/../images/img-20250706145445256.png\"></li>\n<li>思路分析</li>\n<li><img src=\"/../images/img-20250706153240484.png\"></li>\n<li><strong>密文格式解析</strong>（以<code>$2y$10$</code>开头的标准格式为例）：</li>\n<li><code>$2y$</code>：算法标识（BCrypt 的版本）。</li>\n<li><code>10</code>：哈希迭代次数（影响加密强度，数值越大越耗时但更安全）。</li>\n<li><code>eZ6jT65J5dL6</code>：随机生成的盐值（长度通常为 22 个字符）。</li>\n</ul>\n<h3 id=\"为什么相同明文加密结果不同？\"><a href=\"#为什么相同明文加密结果不同？\" class=\"headerlink\" title=\"为什么相同明文加密结果不同？\"></a>为什么相同明文加密结果不同？</h3><ol>\n<li><strong>盐值随机生成</strong>：<br> 每次调用 BCryptEncode 时，算法会自动生成一个新的随机盐值。例如，两次加密 “123” 时，盐值可能分别为<code>eZ6jT65J5dL6</code>和<code>aB3kL9mN7pQ2</code>，与明文结合后计算的哈希结果自然不同。</li>\n<li><strong>盐值包含在密文中</strong>：<br> 密文本身携带了盐值，因此验证密码时无需额外存储盐值 —— 算法会从密文中提取盐值，再与用户输入的密码结合，重新计算哈希并与密文中的哈希值比对。</li>\n</ol>\n<ul>\n<li>Session无法在集群模式下使用</li>\n<li>因为原生 Session 依赖单服务器存储，无法跨服务器共享数据。但通过<strong>Session 粘性</strong>或<strong>分布式 Session 存储</strong>等方案，可在集群中正常使用 Session，实现用户会话状态的管理。</li>\n<li><strong>建议</strong>：在现代分布式系统中，优先采用共享存储（如 Redis）实现分布式 Session，既能解决集群环境的兼容性问题，又能提升系统的可扩展性和可靠性。</li>\n</ul>\n<h2 id=\"定义JWT认证过滤器\"><a href=\"#定义JWT认证过滤器\" class=\"headerlink\" title=\"定义JWT认证过滤器\"></a>定义JWT认证过滤器</h2><ul>\n<li><img src=\"/../images/img-20250709104511083.png\"></li>\n</ul>\n<p><strong>名词解释</strong></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UsernamePasswordAuthenticationToken</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractAuthenticationToken</span> {  <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">serialVersionUID</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">550L</span>;  <br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Object principal;  <br>    <span class=\"hljs-keyword\">private</span> Object credentials;<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>principal：<br>  表示身份验证的主要标识，比如用户登录时的用户名或用户对象。<br>  由于它是 final 的，因此在构造函数中初始化之后就不能再改变了，保证了其不可变性。</li>\n<li>credentials：<br>  表示身份验证的凭据，例如用户的密码。<br>  它不是 final 的，意味着可以在后续过程中被修改或清除（例如在认证成功后清除密码）。</li>\n</ul>\n<p><strong>三种不同的Ant匹配模式</strong><br><img src=\"/../images/img-20250709140439366.png\"></p>\n<ol>\n<li>hello路径下允许所有路径的访问吗</li>\n<li><code>anonymous()</code>&nbsp;方法用于配置<strong>匿名访问规则</strong>&nbsp;，允许未认证（未登录）的用户以匿名身份访问匹配的 URL 。<br><strong>tips：</strong></li>\n</ol>\n<ul>\n<li><strong>permitAll</strong>：完全公开，谁都能看。</li>\n<li><strong>anonymous</strong>：只给没登录的人看，登录后就不能看了。</li>\n<li><strong>authenticated</strong>：必须登录，没登录就不让看。</li>\n</ul>\n<h1 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h1><p>主要做两件事：</p>\n<ul>\n<li>限制访问资源所需权限</li>\n<li>将权限封装到authentication中</li>\n</ul>\n<h1 id=\"从数据库中查询权限信息\"><a href=\"#从数据库中查询权限信息\" class=\"headerlink\" title=\"从数据库中查询权限信息\"></a>从数据库中查询权限信息</h1><ul>\n<li><strong>RBAC权限模型</strong></li>\n<li>基于角色进行控制</li>\n<li>分为五张表张表：用户表、权限表、角色表、用户角色管理表、角色权限管理表<img src=\"/../images/img-20250709155734696.png\"></li>\n<li>角色表：把权限分为一组一组，不同的角色有不同的权限组，避免用户量大的时候，减少用户表和权限表之间权限管理繁琐 <ul>\n<li>一个角色有多个权限，但一个权限也有多个角色，是一种多对多的关联关系，所以要有一个多对多的角色权限关联表</li>\n</ul>\n</li>\n<li>我自己的感受就是，一个人的所有角色可以用一个字段保存，保存成一个字符串，取出来的时候把不同的角色用不同的符号间隔取出，做一个关联子表的好处可能就是不用在代码层面上间隔取出来，而是转为在数据库中直接查询出所有的数据并且返回为List格式就行了，但是我刚刚ai了一下，多对多的两个表如果不用中间表的话会造成数据的冗余和数据记录数压力大的问题，这跟我一开始对于数据是否在代码层面间隔取出作为list的看法其实并不是重要因素，反而是数据量大的因素更会造成不可估计的系统压力。</li>\n<li>这个地方比较难理解的就是关联表维护多对多数据模型的优势</li>\n<li>另外权限表一般命名为menu表，可以理解为把所有的功能作为一个菜单保存</li>\n</ul>\n<h1 id=\"自定义异常处理\"><a href=\"#自定义异常处理\" class=\"headerlink\" title=\"自定义异常处理\"></a>自定义异常处理</h1><p><img src=\"/../images/img-20250709165113294.png\"></p>\n<ol>\n<li>继承并实现处理这两个异常处理接口<img src=\"/../images/img-20250710095949765.png\"></li>\n<li>添加这两个异常到SecurityConfig中<img src=\"/../images/img-20250710100516458.png\"></li>\n</ol>\n<h1 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h1><ol>\n<li>重写spring提供的WebMvcConfigurer接口的addCorsMappings方法</li>\n<li>设置security运行跨域访问</li>\n</ol>\n<h1 id=\"自定义权限校验方法\"><a href=\"#自定义权限校验方法\" class=\"headerlink\" title=\"自定义权限校验方法\"></a>自定义权限校验方法</h1><ol>\n<li>自定义表达式组件并给组件命名<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Component(\"aaa\")</span>  <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyExpressionRoot</span> {  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">hasAuthority</span><span class=\"hljs-params\">(String authority)</span> {  <br>        <span class=\"hljs-comment\">// 获取当前用户的权限  </span><br>        <span class=\"hljs-type\">Authentication</span> <span class=\"hljs-variable\">authentication</span> <span class=\"hljs-operator\">=</span> SecurityContextHolder.getContext().getAuthentication();  <br>        <span class=\"hljs-type\">LoginUser</span> <span class=\"hljs-variable\">loginUser</span> <span class=\"hljs-operator\">=</span> (LoginUser) authentication.getPrincipal();  <br>        List&lt;String&gt; permissions = loginUser.getPermissions();  <br>        <span class=\"hljs-comment\">//判断用户权限集合中是否存在authority  </span><br>        <span class=\"hljs-keyword\">return</span> permissions.contains(authority);  <br>    }  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n<li>@组件名进入使用<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@PreAuthorize(\"@aaa.hasAuthority('system:dept:list')\")</span>  <br><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span>  <br>{  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"你好世界\"</span>;  <br>}<br></code></pre></td></tr></tbody></table></figure></li>\n</ol>\n<ul>\n<li>目前authentication中包含的东西<img src=\"/../images/img-20250710145543645.png\"></li>\n</ul>\n<h1 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h1><ul>\n<li>跨站请求伪造，web常见攻击</li>\n<li>如果不关闭的话，除了校验自己做的token，还会校验CSRF的token</li>\n</ul>\n<h1 id=\"知乎好文讲解\"><a href=\"#知乎好文讲解\" class=\"headerlink\" title=\"知乎好文讲解\"></a>知乎好文讲解</h1><p><img src=\"/../images/img-20250708101247955.png\"></p>\n<ul>\n<li>补充：A（service） &lt;—  B（serviceImpl）主要是强调一个指向关系（虚线空心箭头），子指向父<br><img src=\"/../images/img-20250708103327542.png\"></li>\n<li>Principal是谁在访问的“身份标识”，继承他就会贴上一个身份标签，继承后类就会被安全框架自动识别，无需额外配置，主要包含名称、权限、凭证</li>\n</ul>\n","categories":["Spring","Java","笔记"],"tags":["Java","项目笔记"]},{"title":"SpringBoot3","url":"/posts/1432709709.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>SpringBoot3读书笔记</p>\n<span id=\"more\"></span>\n<h3 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h3><hr>\n<h4 id=\"IOC思想的引入\"><a href=\"#IOC思想的引入\" class=\"headerlink\" title=\"IOC思想的引入\"></a>IOC思想的引入</h4><ul>\n<li><img src=\"/../images/img-20250802033834788.png\"><br><strong>两种实现方式</strong></li>\n</ul>\n<ol>\n<li>依赖查找 <img src=\"/../images/img-20250802193405393.png\"></li>\n<li>依赖注入 <img src=\"/../images/img-20250802193342507.png\"></li>\n</ol>\n<ul>\n<li>依赖注入是 “别人给啥用啥”，依赖查找是 “自己找想要的”</li>\n</ul>\n<p><strong>IOC容器基本处理流程</strong></p>\n<ul>\n<li><img src=\"/../images/img-20250802195902802.png\"></li>\n</ul>\n<p><strong>对比BeanFactory与ApplicationContext</strong></p>\n<ul>\n<li><img src=\"/../images/img-20250802200055316.png\"><br><strong>BeanFactory与ApplicationContext的特性对比</strong></li>\n<li><img src=\"/../images/img-20250802200126082.png\"><br><strong>理解Context与ApplicationContext</strong></li>\n<li><img src=\"/../images/img-20250802200427916.png\"></li>\n<li><img src=\"/../images/img-20250802200434936.png\"></li>\n</ul>\n<h3 id=\"注解驱动的IOC\"><a href=\"#注解驱动的IOC\" class=\"headerlink\" title=\"注解驱动的IOC\"></a>注解驱动的IOC</h3><h3 id=\"依赖查找进阶和高级\"><a href=\"#依赖查找进阶和高级\" class=\"headerlink\" title=\"依赖查找进阶和高级\"></a>依赖查找进阶和高级</h3><h3 id=\"依赖注入的6种方式\"><a href=\"#依赖注入的6种方式\" class=\"headerlink\" title=\"依赖注入的6种方式\"></a>依赖注入的6种方式</h3><h2 id=\"IOC容器中的Bean\"><a href=\"#IOC容器中的Bean\" class=\"headerlink\" title=\"IOC容器中的Bean\"></a>IOC容器中的Bean</h2><hr>\n<h3 id=\"Bean的类型\"><a href=\"#Bean的类型\" class=\"headerlink\" title=\"Bean的类型\"></a>Bean的类型</h3><h3 id=\"Bean的作用域\"><a href=\"#Bean的作用域\" class=\"headerlink\" title=\"Bean的作用域\"></a>Bean的作用域</h3><h3 id=\"Bean的实例化方式\"><a href=\"#Bean的实例化方式\" class=\"headerlink\" title=\"Bean的实例化方式\"></a>Bean的实例化方式</h3><h3 id=\"Bean的基本生命周期\"><a href=\"#Bean的基本生命周期\" class=\"headerlink\" title=\"Bean的基本生命周期\"></a>Bean的基本生命周期</h3><h2 id=\"IOC容器的设计与机制\"><a href=\"#IOC容器的设计与机制\" class=\"headerlink\" title=\"IOC容器的设计与机制\"></a>IOC容器的设计与机制</h2><hr>\n<h3 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h3><h3 id=\"事件驱动与监听器\"><a href=\"#事件驱动与监听器\" class=\"headerlink\" title=\"事件驱动与监听器\"></a>事件驱动与监听器</h3><h3 id=\"模块装配\"><a href=\"#模块装配\" class=\"headerlink\" title=\"模块装配\"></a>模块装配</h3><h3 id=\"条件装配\"><a href=\"#条件装配\" class=\"headerlink\" title=\"条件装配\"></a>条件装配</h3><h3 id=\"组件扫描机制\"><a href=\"#组件扫描机制\" class=\"headerlink\" title=\"组件扫描机制\"></a>组件扫描机制</h3><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","categories":["Java","SpringBoot"],"tags":["阅读笔记","SpringBoot3"]},{"title":"关于最近的牛马生活","url":"/posts/1556965081.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>记载一下最近几天的工作烦心事</p>\n<span id=\"more\"></span>\n<p>2025-05-20</p>\n<ul>\n<li>这几天工作中遇到了很多烦心事，主要是还是老板情商低嘴下不留情，不指导工作然后一直用各种话语刁难我跟同事，反感。</li>\n<li>原本打算说很多的，但是都是情绪没有排泄的缘由，仔细说其实就是工作人遇到的一些挫折困难；通过今天的挫折，我越发想提前学习技能知识早点跑路，今天的事情就这样过去吧，多做对自己有用的事情。暂时的计划就是：先苟着，然后快速提升自己的干活能力，只要干活快了才有时间提前完成任务再做自己的事情，然后自己的时间就用来学技能知识提高干活速度，最后就是学习yan的东西。</li>\n</ul>\n<p>2025-05-22</p>\n<ul>\n<li>今天又是难受的一天，老板又说话tm的跟sb一样，真是想走了。然后矛盾在现在还要继续赚钱打工，然后还要表现出一副讨好不膈应的状态和表情。累啊，真是tm的c蛋，行走江湖给人打工真是受不了被老板莫名其妙的一顿叼，真是sb老板。现在只想感觉多学点早点跑路。</li>\n</ul>\n<p>2025-06-05 20:56</p>\n<ul>\n<li>生活已经来到了六月，时间过去的是真快，工作上打算先走一步看一步，经历过这几年这么多事情之后，对当下很多的事情其实就是走一步看一步的心态，也许有时候会对生活有些惋惜，但是那终将是过去，早点从情绪中走出来并寻求新的办法才是当下所要做的事情。</li>\n<li>这一个月算是关键的一个月了，技术要学，可能工作也要换，但是不怕，竹杖芒鞋轻胜马，谁怕，一蓑烟雨任平生！</li>\n</ul>\n<p>2025-06-06 21:17</p>\n<ul>\n<li>又开始了些许害怕，害怕自己不思进取，害怕自己前途黯淡。算了，路还是要走的，多多提醒自己，人在路上心在路上；只是想让自己走的踏实，而不是每一步都是为了别人而走，要为自己活着，为自己而进取。</li>\n<li>佩服那些能把不喜欢的事情变成喜欢的，把不擅长的变成擅长的那些人</li>\n</ul>\n<p>2025-06-11 00:33</p>\n<ul>\n<li>在公司这段时间感觉有点被驯化了的样子，逐渐意识到社会的真实的一面，现在如果没有技术、没有钱权名利，是怎么也抬不起头的，没有学校里面唯分数论那样只看自己的成绩了；现在是愈来愈意识到自己的渺小，逐渐看到职场的另一套玩法，一种互相交换和对冲的职场。现在，理想的想法就是：学习职场那一套，社会那一套，在外面玩社会上的那套，在家可以真正的做自己。也许我上述所说的并没有什么值得颇为惊人的，但是这对于我的思想又是一种冲击。我也不想自己因为钱把自己变成一个纯粹的只为金钱的人。反而是愈发经历这些事，越感受到自己和社会的距离，感受到一种思想的撞击，而我又是害怕巨大变化的人，是一个感性的人。现实就像一只老虎一样撕碎我对生活的幻想，让我感受到社会真正追捧的东西。而我也要把自己伪装成一个战士出来迎接迎面的撞击。</li>\n</ul>\n<p>2025-06-24 23:27</p>\n<ul>\n<li>今天老弟回家了，剩下的生活又要靠自己去打拼了，今天想明白一件事：生活就是不断在求稳和求进之间来回轮转，生活不是直线上升的，而是螺旋的，所以后面的生活还是得靠自己慢慢拼</li>\n<li>锻炼自己绝对冷静的能力，对生活中每一件事都平静，平静是把生活的利器，是自己的后备隐藏能源</li>\n</ul>\n<p>2025-06-29 14:54</p>\n<ul>\n<li>先礼后兵，不要上来就带着情绪</li>\n<li>而且情绪要得当作一种最后的最后的武器来使用，如果有其他的办法还是思考着解决问题，不能习惯用情绪去沟通</li>\n</ul>\n","categories":["工作"],"tags":["工作","胡言乱语"]},{"title":"《新摄影笔记》","url":"/posts/1860912074.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>有感而发记录一些对摄影有帮助的句子</p>\n<span id=\"more\"></span>\n<ul>\n<li>在平凡中拍摄到不凡的瞬间</li>\n<li>一直追求的目标：<strong>在平凡中拍摄到不凡的瞬间</strong></li>\n<li>记录的场景可以让别人看了之后感受到同样的触动</li>\n<li>确立画面主题，可以用放大的效果去掉周边复杂的元素，达到自然裁切</li>\n<li>拍摄时候把光圈开到最大用虚化来让画面虚实结合、主体清晰、环境虚化，这样更容易突出主体</li>\n<li>构图上把人物放在左侧三分之一处，让人更容易看到主体</li>\n<li>拍摄照片做到：<ul>\n<li>有一个值得记录的主题</li>\n<li>通过摄影技巧将这个主题记录好</li>\n</ul>\n</li>\n<li>记住：<strong>摄影就是记录下您到达并发现的、触动您内心的场景及瞬间。</strong></li>\n<li>把摄影技巧分为了4个方面：取景、曝光、虚实及构图</li>\n<li><strong>取景</strong>：把摄影技巧分为了4个方面：取景、曝光、虚实及构图<ul>\n<li>取景时我们要注意取景内容、取景范围、取景时机及取景角度。</li>\n<li>取景决定了画面中有哪些元素，以及画面中每个元素的状态。取景将是您在摄影中需要一直学习的内容，是最难的和最重要的。</li>\n</ul>\n</li>\n<li><h2 id=\"曝光：简单说就是一张照片的明暗。说的复杂一点，就是控制照片中各个元素的色彩与明暗。-点测光，顾名思义，就是只对一个点进行测光，该点通常和对焦点在同一个位置，（其实是一个非常小的区域而已，不是完全的点）-拍摄模式-M档：手动曝光（可以调节各参数来达到更理想的创作）-A档：光圈优先（光圈可以人为手动控制，而快门相机会自动计算）-S档：快门优先（快门可以人为手动控制，而光圈相机会自动计算）-P档：程序自动（不会调参数时，可以先玩P档）-测光：相机对拍摄话画面的明暗进行测量，以此来调整曝光参数达到比较理想的曝光。\"><a href=\"#曝光：简单说就是一张照片的明暗。说的复杂一点，就是控制照片中各个元素的色彩与明暗。-点测光，顾名思义，就是只对一个点进行测光，该点通常和对焦点在同一个位置，（其实是一个非常小的区域而已，不是完全的点）-拍摄模式-M档：手动曝光（可以调节各参数来达到更理想的创作）-A档：光圈优先（光圈可以人为手动控制，而快门相机会自动计算）-S档：快门优先（快门可以人为手动控制，而光圈相机会自动计算）-P档：程序自动（不会调参数时，可以先玩P档）-测光：相机对拍摄话画面的明暗进行测量，以此来调整曝光参数达到比较理想的曝光。\" class=\"headerlink\" title=\"曝光：简单说就是一张照片的明暗。说的复杂一点，就是控制照片中各个元素的色彩与明暗。  - 点测光，顾名思义，就是只对一个点进行测光，该点通常和对焦点在同一个位置，（其实是一个非常小的区域而已，不是完全的点）  - 拍摄模式      - M档：手动曝光（可以调节各参数来达到更理想的创作）      - A档：光圈优先（光圈可以人为手动控制，而快门相机会自动计算）      - S档：快门优先（快门可以人为手动控制，而光圈相机会自动计算）      - P档：程序自动（不会调参数时，可以先玩P档）  - 测光：相机对拍摄话画面的明暗进行测量，以此来调整曝光参数达到比较理想的曝光。\"></a><strong>曝光</strong>：简单说就是一张照片的明暗。说的复杂一点，就是控制照片中各个元素的色彩与明暗。<br>  - 点测光，顾名思义，就是只对一个点进行测光，该点通常和对焦点在同一个位置，（其实是一个非常小的区域而已，不是完全的点）<br>  - 拍摄模式<br>      - M档：手动曝光（可以调节各参数来达到更理想的创作）<br>      - A档：光圈优先（光圈可以人为手动控制，而快门相机会自动计算）<br>      - S档：快门优先（快门可以人为手动控制，而光圈相机会自动计算）<br>      - P档：程序自动（不会调参数时，可以先玩P档）<br>  - 测光：相机对拍摄话画面的明暗进行测量，以此来调整曝光参数达到比较理想的曝光。</h2></li>\n<li><img src=\"/../images/img-20250525173203610.png\"></li>\n</ul>\n<h1 id=\"取景\"><a href=\"#取景\" class=\"headerlink\" title=\"取景\"></a>取景</h1><hr>\n<ul>\n<li><p>焦距</p>\n<ul>\n<li><img src=\"/../images/img-20250525173728561.png\"></li>\n<li><strong>超广角</strong>焦距一般指的是24mm以下的焦距<ul>\n<li>适合拍摄大场景，建筑啊、风景啊。也适合在狭小空间内部拍摄，能把小空间拍摄得“很大”​</li>\n</ul>\n</li>\n<li><strong>标准广角：</strong> 24~28mm</li>\n<li><strong>一般广角：</strong> 35mm被称为“大师的焦距”​，也被称为“人文眼，拍摄人文题材的合适焦距</li>\n<li><strong>标准镜头：</strong> 50mm焦距近似人眼的透视效果，适合拍摄人文照片，同时一般光圈较大，能有很好的背景虚化效果</li>\n<li><strong>人像镜头：</strong> 85mm；有很好的背景虚化效果，很好的画面裁切能力，还能保持和模特之间有适当的“交流”距离。其实很多焦距(55~135mm)都可以拍摄人像，当然，用85mm焦距拍摄人像，尤其是拍特写会很好看。另外，可能因为85mm焦距的镜头除了适合拍摄人像，在其他方面并不是很擅长吧，所以被称为人像镜头</li>\n<li><strong>超广角变焦镜头：</strong> 指的是从11mm、12mm、14mm、16mm、18mm这样的超广角焦距“起跳”​，直到24mm、35mm这样的焦距截止的镜头，可以实现超广角到一般广角不同焦距的变化。比如较为常见的16-35mm镜头</li>\n<li><strong>标准变焦镜头：</strong> 指从24mm或者28mm起跳，直到70mm、85mm、105mm、120mm截止的镜头 ;常见的两种题材——风光（广角拍摄）和人像（中焦）​，所涉及的焦距都涵盖在内。大家熟知的24-70mm镜头就属于这个范畴。</li>\n<li><strong>长焦镜头：</strong> 200mm和300mm就是妥妥的长焦镜头了，可用于拍摄鸟类啊，荷花啊，运动物体啊，那种离得不是很远的就可以“打”得到了。所以这种焦距的镜头也被称为望远镜头或者摄远镜头，多用于拍摄远处的景物。</li>\n<li><strong>超长焦镜头：</strong> 300mm焦距以上的镜头，适合拍摄野生动物、运动题材等。也适合拍日出、日落，满月、弦月等的特写。</li>\n<li><strong>超长焦变焦镜头：</strong> 超长焦变焦镜头一般指的是从150mm、200mm起，直到500mm、600mm截止的镜头。这类镜头适合拍摄远的景物。较常见的就是拍野生动物题材了。</li>\n</ul>\n</li>\n<li><p>最后注意，焦距和题材没有绝对的关系！</p>\n</li>\n<li><p>由于APSC画幅的传感器小，所以同样的镜头得到的视角等于是从原来的视角里面剪出来一块。所以等效焦距会变长。</p>\n</li>\n<li><p>200mm变成300mm是因为我们乘了1.5的焦距转换系数。对APS-C画幅来说，除了佳能相机是×1.6，其他品牌的相机都是×1.5，松下和奥之心（原奥林巴斯）的M/43系统是×2，因为传感器更小，所以等效焦距会变得更长。</p>\n</li>\n<li><p>实际焦距×焦距转换系数=35mm焦距等效焦距</p>\n</li>\n<li><p>简单总结如下。</p>\n<ul>\n<li>(1)全画幅相机只能用全画幅镜头。</li>\n<li>(2)全画幅镜头既可以用在全画幅相机上，也可以用在半画幅相机（APS-C画幅相机的俗称）上</li>\n<li>(3)可换镜头上面标注的焦距都是实际焦距。全画幅镜头和半画幅专用镜头都是如此。</li>\n<li>(4)只要是半画幅机身，不管用什么镜头，就一定要通过焦距转换系数来求得等效焦距。</li>\n<li>(5)全画幅系数是1，就是不需要计算，等效焦距就是实际焦距。</li>\n<li>尼康、索尼、宾得、富士半画幅相机的焦距转换系数是1.5。</li>\n<li>佳能半画幅相机的焦距转换系数是1.6。奥之心和松下的M/43系统是乘2。</li>\n</ul>\n</li>\n<li><p>为什么说全画幅相机只能用全画幅镜头呢？以佳能相机为例，APS-C相机的镜头后组大，往往装不进全画幅机身，硬装进去可能会损坏相机。而索尼和尼康相机的则可以装进去，但是相机会变成APS-C画幅模式，传感器外面一大圈不起作用。如2400万像素的全画幅，可能就会变为1100万像素的半画幅。这多么浪费。也有一些APS-C的镜头像场比较大，在全画幅机身上使用就会有一些暗角，但是这种镜头数量不多。</p>\n</li>\n<li><p>中画幅相机的电子传感器比135全画幅的更大，所以焦距转换系数比1还要小。</p>\n</li>\n<li><p>当我们说到焦距与题材的时候，说的都是35mm等效焦距或者说135等效焦距。</p>\n</li>\n</ul>\n<h1 id=\"透视\"><a href=\"#透视\" class=\"headerlink\" title=\"透视\"></a>透视</h1><hr>\n<p>经常有人问我有关“画面深度”​“景物似乎拉近了”之类的。很多“半懂不懂”的话，不知道他们是被什么影响了，但是在我看来这根本说的就是透视这件事。</p>\n<p>我们常听说用广角镜头拍摄会有空间感，用长焦镜头拍摄几乎没有空间感。广角镜头可以让画面有很强的纵深感，而长焦镜头会让画面看起来更加扁平。其实这个说法也不对。到底是怎么回事呢？那就要说到现在要讲的这个知识点——透视。什么是透视呢？简单说就是“近大远小”​。</p>\n<p>近大远小这样的透视效果，拍摄距离越近则越明显。当我们使用广角镜头拍摄时，我们往往会离拍摄的主体比较近。正是因为离得近，所以透视效果明显，近大远小明显。在画面中近的东西会变得更大，远的东西会变得更小。</p>\n<p>相反，当我们使用长焦镜头拍摄时，我们往往会离拍摄的主体比较远。正是因为离得远，所以透视效果不明显，近大远小不明显。在画面中近的东西会变得没那么大，远的东西也会变得没那么小，因此更趋近于真实的比例。</p>\n<p>这也说明了焦距与透视的一些间接关系：因为使用广角镜头拍摄往往离得近，所以透视效果明显；因为使用长焦镜头拍摄往往离得远，所以透视效果不明显。</p>\n<p>在拍摄建筑物的时候，您往往会发现建筑物底部大、上部小，原本方形的建筑总会变成梯形。其实这也是透视效果造成的。建筑物底部离您近，而上部离您远——因为一般都是在地面上仰拍，所以离您近的显得大，离您远的显得小。<br>这一点从这张照片更容易看出来。一座桥离您近的地方左、右两个桥墩彼此间距还离得远一些，离您远的地方两个桥墩逐渐聚拢。</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><hr>\n<ul>\n<li><img src=\"/../images/img-20250525193423022.png\"></li>\n<li></li>\n</ul>\n","categories":["阅读"],"tags":["摄影","读后感"]},{"title":"养生","url":"/posts/2634996229.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>写一些关于养生的话题</p>\n<span id=\"more\"></span>\n\n<h1 id=\"放松肌肉\"><a href=\"#放松肌肉\" class=\"headerlink\" title=\"放松肌肉\"></a>放松肌肉</h1><hr>\n<p><strong>头颈拉伸</strong></p>\n<p>右手举过头顶，将头部向右侧拉动，反复几次，换左手重复动作。</p>\n<p><strong>肩部拉伸</strong></p>\n<p>左手将伸直的右手托起平举，向左拉伸，换手重复动作。</p>\n<p><strong>胸部拉伸</strong></p>\n<p>双手平举，做扩胸运动。</p>\n<p><strong>二头肌拉伸</strong></p>\n<p>手臂侧平举，手扶住墙角或者任何够高的支撑物，转动上身，坚持10～15秒。</p>\n<p><strong>三头肌拉伸</strong></p>\n<p>用一只手抓住另一只手的肘关节，轻推且越过身体，直到手触摸到后背。</p>\n<p><strong>臀肌拉伸</strong></p>\n<p>左腿放在右腿上，保持弯曲。尽力让左腿触碰胸部，向左扭转身体，眼睛尽力看向左肩。</p>\n<p><strong>大腿外侧拉伸</strong></p>\n<p>被拉伸的大腿向斜后方伸出，小腿与脚的外侧面着地，另一侧的大腿做前弓步、膝关节屈曲，双手扶地支撑。拉伸时，身体重心移向被伸拉的一侧。</p>\n<p><strong>四头肌拉伸</strong></p>\n<p>单脚站立，身体保持直立。一手扶墙保持平衡，另一只手向上拉同侧脚尖。</p>\n<p><strong>小腿拉伸</strong></p>\n<p>一条腿向前跨一大步，另一条腿不动，身体前压&nbsp;。</p>\n<p><strong>上背拉伸</strong></p>\n<p>直立，双手抓住与腹部齐高的扶手，后背反复弓起、下压。</p>\n<p><strong>下腰拉伸</strong></p>\n<p>仰卧，双腿弯曲，双手抱起小腿，尽量向胸部拉伸。重复10次，每次30秒。</p>\n<p>做拉伸运动要注意拉伸时身体放松，以肌肉、肌腱、韧带有轻微拉动感为宜；每个动作最好持续30秒以上，每组间隔15～30秒；深呼吸有助于将富含氧气的动脉血液输送至酸痛的肌肉部位。</p>\n","categories":["养生","锻炼"],"tags":["健康","锻炼"]},{"title":"加强学习","url":"/posts/151821141.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>写一些关于有关学习或者学习中带来的思考</p>\n<span id=\"more\"></span>\n\n<h1 id=\"关于学习\"><a href=\"#关于学习\" class=\"headerlink\" title=\"关于学习\"></a>关于学习</h1><ol>\n<li>如果想好了做一件事就认真去做，做的过程中不去思考事情以外的事情，无论能不能做好，态度不可以懈怠，学习的过程中要不断的精进自己的学习方法，在学完这件事的时候总结学习方法并不断精进自己的学习方法。</li>\n</ol>\n<h1 id=\"学习方法\"><a href=\"#学习方法\" class=\"headerlink\" title=\"学习方法\"></a>学习方法</h1><ol>\n<li>不断的思考对比总结 思考对比总结</li>\n<li>做什么事情都不能一直死做，</li>\n</ol>\n","categories":["学习"],"tags":["胡言乱语","学习","尝试"]},{"title":"国补下单能手","url":"/posts/66500121.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>趁着国补和618活动前夕买了mini主机、键鼠和显示器</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一共消费三千大米-商品图-买了主机但是不能老蹭公司电脑用，还得自己搞一个屏幕才行，所以又买了个屏幕，说实话比我公司的那个屏幕好，物超所值-帮同学做了个单子赚了点米，又想着买一个只用插信号接收器就能控制键鼠同时用哪个设备的，方便从mini主机切换到笔记本电脑上-刚拿到手的时候震撼的是这个键盘感觉就只有一块板，薄的闻所未闻，但是用下来发现可以手掌一直放在桌面上，不用把手掌抬起来用，还是非常舒服的，加上这个鼠标也不错，不愧是九十多的键鼠。这个键鼠买的按理说其实算贵了，但是自己可能由于稍微赚了点饭钱就觉得赚的钱不用白不用，造成一个消费观念被扩容的错觉。-总结\"><a href=\"#一共消费三千大米-商品图-买了主机但是不能老蹭公司电脑用，还得自己搞一个屏幕才行，所以又买了个屏幕，说实话比我公司的那个屏幕好，物超所值-帮同学做了个单子赚了点米，又想着买一个只用插信号接收器就能控制键鼠同时用哪个设备的，方便从mini主机切换到笔记本电脑上-刚拿到手的时候震撼的是这个键盘感觉就只有一块板，薄的闻所未闻，但是用下来发现可以手掌一直放在桌面上，不用把手掌抬起来用，还是非常舒服的，加上这个鼠标也不错，不愧是九十多的键鼠。这个键鼠买的按理说其实算贵了，但是自己可能由于稍微赚了点饭钱就觉得赚的钱不用白不用，造成一个消费观念被扩容的错觉。-总结\" class=\"headerlink\" title=\"一共消费三千大米# 商品图- - 买了主机但是不能老蹭公司电脑用，还得自己搞一个屏幕才行，所以又买了个屏幕，说实话比我公司的那个屏幕好，物超所值- - 帮同学做了个单子赚了点米，又想着买一个只用插信号接收器就能控制键鼠同时用哪个设备的，方便从mini主机切换到笔记本电脑上- - 刚拿到手的时候震撼的是这个键盘感觉就只有一块板，薄的闻所未闻，但是用下来发现可以手掌一直放在桌面上，不用把手掌抬起来用，还是非常舒服的，加上这个鼠标也不错，不愧是九十多的键鼠。这个键鼠买的按理说其实算贵了，但是自己可能由于稍微赚了点饭钱就觉得赚的钱不用白不用，造成一个消费观念被扩容的错觉。# 总结\"></a>一共消费三千大米<br># 商品图<br>- <img src=\"/../images/img-20250519002400626.png\"><br>- 买了主机但是不能老蹭公司电脑用，还得自己搞一个屏幕才行，所以又买了个屏幕，说实话比我公司的那个屏幕好，物超所值<br>- <img src=\"/../images/img-20250519002537646.png\"><br>- 帮同学做了个单子赚了点米，又想着买一个只用插信号接收器就能控制键鼠同时用哪个设备的，方便从mini主机切换到笔记本电脑上<br>- <img src=\"/../images/img-20250519002731973.png\"><br>- 刚拿到手的时候震撼的是这个键盘感觉就只有一块板，薄的闻所未闻，但是用下来发现可以手掌一直放在桌面上，不用把手掌抬起来用，还是非常舒服的，加上这个鼠标也不错，不愧是九十多的键鼠。这个键鼠买的按理说其实算贵了，但是自己可能由于稍微赚了点饭钱就觉得赚的钱不用白不用，造成一个消费观念被扩容的错觉。<br># 总结</h2><ul>\n<li>有了这套装备以后就可以回来继续学习了，也可以给老弟学剪辑啥的用。然后成本也真是三千，相对于花2999买一个16+256的Macmini还是划算不少的；</li>\n<li>mini主机到我写文章为止已经有两次断电强制关机了，这是让我最心疼的地方；</li>\n<li>这个显示器看评论说不行，拿到手看还是OK的，就是不知道能撑多久；</li>\n</ul>\n","categories":["购物"],"tags":["数码产品","国补"]},{"title":"基础理论知识补充","url":"/posts/2782156371.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><img src=\"/images/file-20241023081927058.png\"></p>\n<p><strong>补充在计算机基础学习过程中遇到的疑惑点</strong></p>\n<span id=\"more\"></span>\n<h1 id=\"数据总线双向三态\"><a href=\"#数据总线双向三态\" class=\"headerlink\" title=\"数据总线双向三态\"></a>数据总线双向三态</h1><p><strong>数据总线双向三态是一种在计算机硬件中用于数据传输的机制，它允许数据在总线上进行双向传输，并且可以处于高阻态</strong>。以下是对数据总线双向三态的具体说明：</p>\n<ol>\n<li><p><strong>双向性</strong>：数据总线的双向性意味着它可以支持数据的双向流动。具体来说，数据既可以通过总线从CPU传送到其他设备（如存储器或I/O接口），也可以从这些设备传送回CPU。这种双向性使得数据总线非常灵活，能够适应多种不同的数据传输需求[^1^]。</p>\n</li>\n<li><p><strong>三态特性</strong>：三态是指总线可以处于三种不同的状态：高电平（逻辑“1”）、低电平（逻辑“0”）和高阻态（通常用符号Z表示）。高阻态是一种特殊状态，在这种状态下，总线既不输出高电平也不输出低电平，相当于与外部电路断开，不会影响到其他设备的正常工作[^3^][^4^]。</p>\n</li>\n<li><p><strong>使能控制</strong>：三态门通过一个使能信号（EN）来控制其输出状态。当使能信号为高电平时，三态门正常工作，输出高电平或低电平；当使能信号为低电平时，三态门输出高阻态。这种设计使得多个设备可以共享同一条总线而不会发生冲突[^4^]。</p>\n</li>\n<li><p><strong>应用场景</strong>：数据总线双向三态广泛应用于各种计算机系统中，特别是在需要频繁进行数据交换的场景中，如内存访问、I/O操作等。此外，在FPGA（现场可编程门阵列）设计中，双向IO口也常使用三态门来实现数据的双向传输[^2^][^5^]。</p>\n</li>\n</ol>\n<p>综上所述，数据总线双向三态是一种高效且灵活的数据传输机制，通过使能信号的控制，实现了数据的双向流动和高阻态输出，从而满足了复杂系统对数据传输的需求。</p>\n<hr>\n<h1 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h1><p>通用寄存器是<strong>处理器中用于存储数据和参与算术逻辑运算的重要组件</strong>。以下是对通用寄存器的详细介绍：</p>\n<ol>\n<li><p><strong>基本概念</strong>：通用寄存器是CPU内部用于暂时存放数据、指令和地址的存储单元。它们的主要功能包括存储临时数据、计算过程中的中间结果，以及作为指针来访问内存地址[^1^]。</p>\n</li>\n<li><p><strong>主要作用</strong>：通用寄存器在计算机系统中扮演着核心角色。它们不仅用于存储数据和指令，还参与到几乎所有的算术和逻辑运算中。例如，加法、减法、乘法和除法等操作都可能需要通用寄存器的参与[^2^]。</p>\n</li>\n<li><p><strong>特殊功能</strong>：除了基本的存储和运算功能外，某些通用寄存器还具有特殊的用途。例如，在8086处理器中，AX寄存器通常被用作累加器，用于执行乘法和除法运算；BX寄存器则常被用作基址寄存器，用于存储内存地址；CX寄存器作为计数器，用于循环和位移操作；DX寄存器则用于I/O操作和乘除运算中的数据暂存[^4^]。</p>\n</li>\n<li><p><strong>分类</strong>：根据不同的处理器架构和设计，通用寄存器可以分为整数寄存器和浮点寄存器两大类。整数寄存器主要用于存储整数数据，而浮点寄存器则用于存储浮点数数据。此外，一些处理器还将通用寄存器设计为具有多个子寄存器或寄存器组的形式，以便更好地支持不同的数据类型和操作[^2^]。</p>\n</li>\n<li><p><strong>应用</strong>：在程序设计中，特别是汇编语言编程中，程序员需要熟悉每个通用寄存器的一般用途和特殊用途，以便在程序中做到正确、合理地使用它们。通过合理利用通用寄存器，可以提高程序的执行效率和性能[^1^][^2^]。</p>\n</li>\n</ol>\n<p>综上所述，通用寄存器在计算机系统中具有举足轻重的地位。它们不仅是数据存储和传输的关键工具，还是算术逻辑运算的核心参与者。</p>\n<hr>\n<h1 id=\"定点运算器\"><a href=\"#定点运算器\" class=\"headerlink\" title=\"定点运算器\"></a>定点运算器</h1><p><strong>定点运算器是一种专门用于执行定点数运算的硬件设备，广泛应用于计算机系统中进行数值计算和数据处理</strong>。以下是对定点运算器的详细介绍：</p>\n<ol>\n<li><strong>概念与应用</strong><ul>\n<li><strong>概念定义</strong>：定点运算器是计算机中的一种重要组成部分，主要用于处理定点数运算。它通过固定小数点位置的方式，对整数和小数部分进行处理[^1^]。</li>\n<li><strong>应用领域</strong>：定点运算器广泛应用于图像处理、音频处理、信号处理、通信系统以及嵌入式系统等领域。随着人工智能和深度学习技术的发展，定点运算器在神经网络模型的部署和推理过程中也发挥着重要作用[^1^]。</li>\n</ul>\n</li>\n<li><strong>基本组成</strong><ul>\n<li><strong>寄存器</strong>：寄存器用于存储操作数和运算结果，包括累加器和数据寄存器等[^1^][^5^]。</li>\n<li><strong>运算单元</strong>：运算单元负责执行各种算术运算，如加法、减法、乘法和除法等[^1^][^3^]。</li>\n<li><strong>控制逻辑</strong>：控制逻辑协调整个运算器的工作流程，控制操作数的输入输出和运算步骤的调度[^1^]。</li>\n</ul>\n</li>\n<li><strong>工作原理</strong><ul>\n<li><strong>操作数输入</strong>：将需要进行运算的定点数从外部输入到定点运算器的寄存器中[^1^]。</li>\n<li><strong>运算操作</strong>：根据指定的运算类型，通过运算单元计算出结果[^1^]。</li>\n<li><strong>结果输出</strong>：将运算得到的结果输出到指定的寄存器中，供后续的运算或输出到外部使用[^1^]。</li>\n</ul>\n</li>\n<li><strong>关键技术</strong><ul>\n<li><strong>乘法运算</strong>：定点运算器中的乘法运算需要考虑定点数的小数位取舍、溢出判断和乘法结果的精度保持等问题[^1^]。</li>\n<li><strong>加减运算</strong>：定点数的加减运算需要考虑进位和溢出的处理，以及结果的精度保持[^1^]。</li>\n</ul>\n</li>\n<li><strong>总线结构</strong><ul>\n<li><strong>单总线结构</strong>：所有部件都接到同一总线上，同一时间内只能有一个操作数放在单总线上[^3^][^5^]。</li>\n<li><strong>双总线结构</strong>：两条总线各自把数据送至ALU的输入端，两个操作数同时加到ALU进行计算[^3^][^5^]。</li>\n<li><strong>三总线结构</strong>：旁路器的作用是不通过ALU实现通用寄存器内的数据传输，速度最快[^3^][^5^]。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong><ul>\n<li><strong>流水线技术</strong>：采用流水线技术可以提高定点运算器的处理速度和效率[^4^]。</li>\n<li><strong>位移技术</strong>：利用位移操作可以简化乘除法运算，提高运算速度[^4^]。</li>\n<li><strong>预测技术</strong>：通过预测技术可以减少运算延迟，提高定点运算器的性能[^4^]。</li>\n</ul>\n</li>\n<li><strong>设计原则</strong><ul>\n<li><strong>指令系统兼容性</strong>：定点运算器的设计需要与指令系统兼容，确保能够正确执行各种指令[^5^]。</li>\n<li><strong>机器字长考虑</strong>：机器字长决定了一次运算的位数和存储器的位数，影响定点运算器的设计[^5^]。</li>\n<li><strong>体系结构适应性</strong>：定点运算器的设计需要考虑整个计算机系统的体系结构，确保其与其他部件的协同工作[^5^]。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，定点运算器是计算机中不可或缺的组成部分，它在数值计算和数据处理方面发挥着重要作用。了解定点运算器的基本概念、组成、工作原理和技术特点，有助于更好地理解和应用这一重要的计算机组件。</p>\n<hr>\n<h1 id=\"CPU内部的时钟频率\"><a href=\"#CPU内部的时钟频率\" class=\"headerlink\" title=\"CPU内部的时钟频率\"></a>CPU内部的时钟频率</h1><p>在计算机领域，CPU的时钟频率是衡量其处理速度的一个重要指标。它代表了CPU每秒钟能够执行的周期数，这个数字越高，通常意味着CPU的运算能力越强。</p>\n<h3 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h3><ul>\n<li><p><strong>基本概念</strong>：时钟频率是指振荡器产生的输入脉冲信号的频率，这个频率是同步电路工作的基准[^1^]。</p>\n</li>\n<li><p><strong>单位</strong>：时钟频率的单位是赫兹（Hz），表示每秒周期性变化的次数[^2^]。</p>\n</li>\n<li><p><strong>重要性</strong>：它是评定CPU性能的重要指标之一，因为时钟频率直接影响着CPU每秒可以执行的指令数[^3^]。</p>\n</li>\n</ul>\n<h3 id=\"二、原因\"><a href=\"#二、原因\" class=\"headerlink\" title=\"二、原因\"></a>二、原因</h3><ul>\n<li><p><strong>命名由来</strong>：时钟频率之所以被称为“时钟”，是因为它就像时钟一样规律地摆动，为CPU提供稳定的工作节奏。CPU的所有操作都按照这个节奏进行，确保了指令的有序执行[^6^]。</p>\n</li>\n<li><p><strong>与时间的关系</strong>：时钟频率与时间紧密相关，它决定了CPU完成任务的速度。高频率意味着CPU可以在更短的时间内完成更多的工作[^7^]。</p>\n</li>\n<li><p><strong>技术实现</strong>：在技术上，CPU通过内部的时钟电路来产生和控制时钟频率。这个频率是通过晶体振荡器产生的，晶体振荡器根据其物理特性在特定条件下以固定频率振动，从而提供稳定的时钟信号[^9^]。</p>\n</li>\n<li><p><strong>发展历史</strong>：从早期的机械齿轮时钟到现代的电子振荡器，时钟技术的发展促进了现代计算机中时钟频率的应用。随着技术的进步，CPU的时钟频率也在不断提高，推动了计算机性能的提升[^10^]。</p>\n</li>\n<li><p><strong>与其他组件的关系</strong>：CPU的时钟频率不仅影响自身的运行速度，还影响与其他硬件组件的数据交换速率。例如，内存和外设也需要与CPU的时钟频率同步，以确保数据的正确传输[^11^]。</p>\n</li>\n<li><p><strong>性能限制因素</strong>：尽管时钟频率对CPU性能至关重要，但它并不是唯一的决定因素。CPU的架构、缓存大小、指令集等也会影响其最终性能[^3^]。</p>\n</li>\n<li><p><strong>能效考量</strong>：随着能源成本的上升和环境保护意识的增强，高时钟频率带来的高能耗问题不容忽视。因此，现代CPU设计中越来越注重能效比，即在提供高性能的同时降低能耗[^7^]。</p>\n</li>\n</ul>\n<p>综上所述，CPU的时钟频率不仅是衡量其性能的关键指标，也是整个计算机系统设计和优化的核心要素。了解时钟频率的定义和它为何被称为“时钟”，有助于深入理解现代计算机的工作原理和性能提升的途径。</p>\n<hr>\n<h1 id=\"为什么Cache-不能由程序或者程序员访问是高速缓存的透明性\"><a href=\"#为什么Cache-不能由程序或者程序员访问是高速缓存的透明性\" class=\"headerlink\" title=\"为什么Cache 不能由程序或者程序员访问是高速缓存的透明性\"></a>为什么Cache 不能由程序或者程序员访问是高速缓存的透明性</h1><p>好的，关于Cache（高速缓存）的透明性，以下是一些解释：</p>\n<ol>\n<li><p><strong>定义与概念</strong>：Cache的透明性指的是在计算机系统中，Cache的存在和操作对程序员来说是不可见的。这意味着程序员不需要直接管理或控制Cache，也不需要为了适应Cache的特性而修改程序代码。</p>\n</li>\n<li><p><strong>透明性的体现</strong>：Cache的管理完全由硬件自动完成，包括数据的读取、写入、替换等操作。这些操作对程序员是透明的，即程序员无法直接感知到这些操作的发生。由于Cache的存在，程序的执行速度得到了提升，但这种提升对程序员来说是“透明”的，即他们不需要为此付出额外的努力或编写额外的代码。</p>\n</li>\n<li><p><strong>透明性的意义</strong>：Cache的透明性简化了程序员的工作，使他们可以专注于编写程序逻辑，而无需关注底层的存储细节。同时，它也使得计算机系统能够更高效地利用资源，提高整体性能。</p>\n</li>\n<li><p><strong>与非透明Cache的区别</strong>：非透明Cache需要程序员显式地控制和管理Cache，这增加了编程的复杂性和难度。而透明Cache则通过硬件自动管理，减轻了程序员的负担。</p>\n</li>\n<li><p><strong>实现方式</strong>：Cache的透明性是通过硬件和操作系统的设计和优化来实现的。例如，现代CPU通常采用多级Cache结构，并通过复杂的替换策略和写回策略来优化Cache的性能。同时，操作系统也会提供相应的支持，以确保Cache的正确性和一致性。</p>\n</li>\n<li><p><strong>对程序员的影响</strong>：虽然Cache对程序员来说是透明的，但这并不意味着程序员可以完全忽略Cache的存在。了解Cache的工作原理和特性对于优化程序性能仍然是非常重要的。然而，在实际编程中，程序员通常不需要直接操作Cache，而是通过编写高效的代码来充分利用Cache的优势。</p>\n</li>\n<li><p><strong>发展趋势</strong>：随着计算机技术的不断发展，Cache的容量和速度都在不断提升，其透明性也在进一步增强。未来的计算机系统可能会采用更先进的Cache技术和算法，以进一步简化程序员的工作并提高系统性能。</p>\n</li>\n</ol>\n<p>综上所述，Cache的透明性是指其在计算机系统中的存在和操作对程序员来说是不可见的。这种透明性简化了程序员的工作，提高了系统性能，并推动了计算机技术的进步和发展。</p>\n<hr>\n<h1 id=\"集成电路\"><a href=\"#集成电路\" class=\"headerlink\" title=\"集成电路\"></a>集成电路</h1><p><strong>集成电路的全称是Integrated Circuit，简称IC</strong>。</p>\n<h2 id=\"电源管理、时钟生成\"><a href=\"#电源管理、时钟生成\" class=\"headerlink\" title=\"电源管理、时钟生成\"></a>电源管理、时钟生成</h2><p><strong>电源管理（Power Management）是指系统在运行过程中对电源的有效控制，以优化功耗和性能；时钟生成（Clock Generation）则涉及为系统各部分提供同步信号，确保它们按照正确的时序工作</strong>。以下是这两个概念的具体介绍：</p>\n<ol>\n<li><strong>电源管理</strong><ul>\n<li><strong>定义与目的</strong>：电源管理是指通过一系列技术和策略，有效控制和管理设备的电源消耗，以延长电池寿命、提高能效并降低运营成本。它涵盖了从硬件设计到软件实现的各个方面[^1^]。</li>\n<li><strong>主要技术</strong>：动态电压频率调节（DVFS）、自适应电压调整（AVS）、电源模式转换（如休眠模式、待机模式）等是现代电源管理中的常用技术。这些技术可以根据系统负载动态调整电源供应，减少不必要的能源浪费[^1^]。</li>\n<li><strong>应用场景</strong>：从个人电子设备（如智能手机、笔记本电脑）到数据中心的大型服务器系统，再到工业自动化和物联网设备，电源管理无处不在，对于提升设备续航能力、降低能耗具有重要意义[^1^]。</li>\n</ul>\n</li>\n<li><strong>时钟生成</strong><ul>\n<li><strong>定义与作用</strong>：时钟生成是指在数字系统中产生稳定、准确的时钟信号的过程。这些信号用于同步系统内各个组件的操作，确保数据处理和传输的准确性和一致性[^2^]。</li>\n<li><strong>关键技术</strong>：锁相环（PLL）、晶体振荡器（Crystal Oscillators）和时钟分配网络（Clock Distribution Networks, CDN）是实现高质量时钟信号的关键组件。PLL可以增加时钟频率的稳定性，而CDN负责将时钟信号分配给系统的各个部分[^2^]。</li>\n<li><strong>应用领域</strong>：从微处理器到FPGA，再到通信设备，时钟生成对于任何需要精确时间控制的数字系统都是必不可少的。特别是在高速数据传输和处理领域，高质量的时钟信号对于保证系统性能至关重要[^2^]。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，电源管理和时钟生成是现代电子系统中不可或缺的两大核心技术。它们分别从能源效率和时间准确性两个方面，共同支撑着系统的高效、稳定运行。</p>\n","categories":["专业课"],"tags":["计算机基础","理论知识"]},{"title":"弱点","url":"/posts/2417479868.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><span id=\"more\"></span>\n","categories":["目录"],"tags":["标签"]},{"title":"想对自己说的话","url":"/posts/2199537027.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>本篇文章是想对现在和将来的自己说一些话，希望能帮助自己走的更远</p>\n<span id=\"more\"></span>\n<h1 id=\"挺一挺就过去了\"><a href=\"#挺一挺就过去了\" class=\"headerlink\" title=\"挺一挺就过去了\"></a>挺一挺就过去了</h1><hr>\n<p><img src=\"/images/img-20241101140250528.png\"><br>非常喜欢龙哥的那句话，<strong>挺一挺就过去了</strong>，这才是一个男人应该做的事情，而不是面对事情难受拒绝、发泄情绪，发泄是女生做的事情，作为一个男人是要无论境遇如何都要咬住牙挺住，不能什么鸡毛蒜皮的事情都放在心上。</p>\n<h1 id=\"大局为重\"><a href=\"#大局为重\" class=\"headerlink\" title=\"大局为重\"></a>大局为重</h1><hr>\n<p>作为男人要以大局为重。放下不值得关注的小事情，做好自己。</p>\n<h1 id=\"在自己可见的前途中行走\"><a href=\"#在自己可见的前途中行走\" class=\"headerlink\" title=\"在自己可见的前途中行走\"></a>在自己可见的前途中行走</h1><hr>\n<p>每当我最难受的时候可能还是因为自己没有走在自己给自己规划的路上。自己不想与更好的自己告别，不想和更好的结果无缘。<br>但如果自己每向前迈出一步，多坚持一会，自己便会离那个结果更近一些，但是路途总是遥远的，过程总是艰辛的，自己有很多可以放弃的理由，那我们为什么还要经历这么多困苦挫折来到这个学校呢，不就是为了在这个平台寻找那个更好的结果吗。<br>现在就站起来继续拼吧，不要再因为其他的理由放弃，走在自己当初希望自己走的路线中，和当初那个雄心满满的我一起走到最后，不让迷茫击倒自己！</p>\n<h1 id=\"把情绪放到思考的下层\"><a href=\"#把情绪放到思考的下层\" class=\"headerlink\" title=\"把情绪放到思考的下层\"></a>把情绪放到思考的下层</h1><hr>\n<p>自己不能以情绪来作为做事的准则，而是要以理智的思考来处理，通过不断的对选择做计算，去获取那个最佳的选择，不断的计算选择，得出最优解，起码让我最后到明年三月份的时候不要再因为情绪再产生其他的不必的事情。通过计算，使得自己的精力和时间得到充分利用。</p>\n<h1 id=\"做好自己\"><a href=\"#做好自己\" class=\"headerlink\" title=\"做好自己\"></a>做好自己</h1><p><img src=\"/../images/img-20241104122718965.png\"></p>\n<h1 id=\"对任何事情不要倾入感情\"><a href=\"#对任何事情不要倾入感情\" class=\"headerlink\" title=\"对任何事情不要倾入感情\"></a>对任何事情不要倾入感情</h1><p>这句话也许很冷漠，但却是很多时候注入感情之后做事会看重结果，但是事情就是事情，没必要为了一些事情大是大非渲染自己的情绪，核心还是自己，做事的过程可以当作是一种体验。很多事情只要自己明白什么是自己真正想要的，那结果随他去吧，真正让自己进步的不是一个两个结果，而是过程中自己一次又一次认真经历。</p>\n<h1 id=\"跟随别人的优秀\"><a href=\"#跟随别人的优秀\" class=\"headerlink\" title=\"跟随别人的优秀\"></a>跟随别人的优秀</h1><p>人生时间有限，每个的结局都是相同，都是躺在地里面；过程可以自己来渲染。成长的过程中，每当我见证别人的优秀的时候都想追随别人的优秀，这不可厚非，追随别人的优秀是我向往更好的自己，是我不愿意一直平庸，不愿意一辈子就什么成就也无，这太没意思了，我要是一点挑战也没有的人云亦云的度过下半辈子，这人生也就太没意思了，这不是我想接受的。我离开这个世界之前我一定是有许多的后悔，但是我想让自己的后悔能少一件就少一件。跟随别人的优秀可以让我能够有一个努力的方向，让我可以一直朝着一个方向努力，实现每一个阶段最好的自己。我不必被周遭不良影响消耗自己的时间和精力。我只是珍惜时间去做好自己，不断的追随更好的自己。</p>\n<h1 id=\"心境、心静\"><a href=\"#心境、心静\" class=\"headerlink\" title=\"心境、心静\"></a>心境、心静</h1><p>可能还是自己接触到的诱惑太多，自己的意志不坚定，目标不够清晰，我主要还是觉得自己不够努力，不够也无所谓，都是过去，只要每一天都记得来时的目的地就行。感觉我这个人做事目标感越来越差了。对了，后面把抖音删了吧，诱惑能控制就控制，不要让自己太分心，坚持不坚持只不过一刹那的想法罢了，只要自己笃定目标，一瞬间所有的多余想法都会灰飞烟灭，所有的选择更加清晰！</p>\n<h1 id=\"任务先行\"><a href=\"#任务先行\" class=\"headerlink\" title=\"任务先行\"></a>任务先行</h1><p>列任务表还是很重要的，想让每天流程化就得这样做，不列的话容易自己想干嘛就干嘛，很容易就去干其他的事情。</p>\n<h1 id=\"愿意改变\"><a href=\"#愿意改变\" class=\"headerlink\" title=\"愿意改变\"></a>愿意改变</h1><p>记得以前自己可以长期让自己去向一件改变靠拢，自己这种长期的主观能动性非常强，那就是我，只不过是曾经的事情，但是不代表以前能做现在就做不了。自己要让自己知道，这是机会，珍惜时间，珍惜机会，让自己主宰自己，而不是被懒惰主宰。</p>\n<h1 id=\"语速放慢\"><a href=\"#语速放慢\" class=\"headerlink\" title=\"语速放慢\"></a>语速放慢</h1><p>自己一直有一个问题，就是语速的问题，当自己语速不能和自己的思考匹配的时候，很容易导致自己病急乱投医，随便说自己想到的一些话。自己今后需要对语速和思考速度方面进行调整，还有就是声音要洪亮清晰。最后总结一下：语速和思考速度匹配；声音洪亮清晰。</p>\n<h1 id=\"减少情绪，理智主导生活\"><a href=\"#减少情绪，理智主导生活\" class=\"headerlink\" title=\"减少情绪，理智主导生活\"></a>减少情绪，理智主导生活</h1><p>针对自己长期心理的逃避生活主要事件，自己应该意识到这是不好的行为，自己摆烂最后导致的结果会非常的糟糕，尽量让自己越来越少的情绪化，取而代之的应该是更多的理智的思考，情绪是耗尽不完的，如果想通过其他手段消耗掉情绪带来的不利影响，这需要很频繁的去刻意消耗，同时会浪费很多精力和时间。所以，减少情绪化，多一些理智的思考。对生活要毅然决然，不能生活起来拖泥带水的。</p>\n<h1 id=\"无论自己做什么事，务必认真\"><a href=\"#无论自己做什么事，务必认真\" class=\"headerlink\" title=\"无论自己做什么事，务必认真\"></a>无论自己做什么事，务必认真</h1><p><img src=\"/../images/img-20241127230743838.png\"></p>\n<h1 id=\"有感而发-2024-11-30\"><a href=\"#有感而发-2024-11-30\" class=\"headerlink\" title=\"有感而发 2024/11/30\"></a>有感而发 2024/11/30</h1><ul>\n<li>最近总是对未来很是焦虑，首先我想在我未来的态度中不要焦虑；那如何界定焦虑呢，大概就是在大脑中总是不断浮起，但是那一刻无法立刻解决焦虑，反复影响自己心态，且不具有帮助自己生活的作用；</li>\n<li>我认为自己的这种焦虑是因为自己还是太浮躁了，我也想在未来自己能够静下来以后需要自己深思熟虑的事情会很多，这一切都需要自己冷静。之前我自己会很顾虑自己的得失，总是患得患失，总是在攀比中让自己产生焦虑，这些事情不仅无意义而且我觉得都是自己浮躁不够冷静的反应，包括自己谈吐也是很浮躁，说的很快且没有思考，希望以后自己能够<strong>深思熟虑</strong>的做事说话；</li>\n<li>对于未来的自己，我想让自己能够持续的情绪稳定，内核稳定，不期望达到处事不惊，能平稳的面对生活中的一切事物就OK；</li>\n<li>突然想起来自己好像很久没有对自己产生期待过了，会想起自己对自己的期待感，那大概就是青春的感觉吧，是一种奋斗的、充实的、沉稳的、无懈可击的感觉，最令我感动的还是晨露的味道，不知不觉距离2015年都10年了，感慨之余，还是希望自己能够不断的向前看，焦虑也是因为回头了太多次产生许多冗余的想法，不管之前是怎样，都已经翻篇，接下来就是冲向未来，冲向更好的自己。</li>\n<li>我认为性格是可以塑造的，就当前来看我挺想刻意为之，培养自己的性格，比如<strong>沉稳、淡定、乐观、果敢、杀伐果断、雷厉风行、积极向上、有野心</strong>，性格不同于人格，我觉得人格更多的是一种品行，更多的涉及到一个人的原则底线，道德素养。性格是培养的苦难，人格除了培养困难之外，坚持也很困难。</li>\n<li>对于人格，我想培养自己<strong>守信、有责任感、坚持和努力</strong>。</li>\n<li>因为很多事情除了别人教我之外，只能自己刻意培养，自己对自己刻意这没什么问题，也许以后我会觉得这是人生的必需品。人生这短短的几十年，如果什么都要别人来可以告诉自己，那我得等到什么时候，不如自己点醒自己。</li>\n<li>我似乎不是太喜欢做一些小事，我觉得从小事做起是一件非常重要，小事不做难以成大事，小事不为，自己也会变得懒惰。</li>\n<li>其他就是希望自己能够改善一下自己的生活作息<ul>\n<li>晚上早点睡觉，把事情记下来留到第二天早上做，这样自己的生活状态也会好一点</li>\n<li>晚上睡觉前不听歌睡觉，安静入睡</li>\n<li>按时洗漱刷牙，做饭尽量控制半小时内</li>\n<li>每天制定大概的几条任务，按照任务来生活</li>\n<li>格式化生活，让自己生活的方方面面的都井井有条些，床、柜子、桌子什么的该收拾收拾一下。</li>\n</ul>\n</li>\n<li>生活中要不断的思考衡量，计算出更优的生活方式，让一切都处于有序的计算之中，让生活有序，人生有序。</li>\n</ul>\n<h1 id=\"能用逻辑思考解决的问题就别动手\"><a href=\"#能用逻辑思考解决的问题就别动手\" class=\"headerlink\" title=\"能用逻辑思考解决的问题就别动手\"></a>能用逻辑思考解决的问题就别动手</h1><ul>\n<li>希望自己能养成思考的习惯，增增加自己的思考敏锐度</li>\n<li>此举是为了提高自己的思考力，从而提高思考效率，节省时间，提高生活效率。</li>\n</ul>\n<h1 id=\"任务学会并行处理\"><a href=\"#任务学会并行处理\" class=\"headerlink\" title=\"任务学会并行处理\"></a>任务学会并行处理</h1><ul>\n<li>多任务处理可以并行处理，不一定非要逐个处置</li>\n</ul>\n<h1 id=\"最惨痛的一天\"><a href=\"#最惨痛的一天\" class=\"headerlink\" title=\"最惨痛的一天\"></a>最惨痛的一天</h1><ul>\n<li>今天转本成绩出来了，还是非常难受的，彷佛自己人生的路有一次被堵上了。但是经历过这次我还是想站起来继续生活，继续寻找新的出路。今晚我彷佛已经不会笑了，压抑、落差顷刻间都出现在我的身上和心里，我再也不想跟任何人联系，更不想跟任何人去发泄心中的苦闷，只想偷偷做点什么事情来尝试挽回自己的未来。难受的是自己只有一个人在走，很多事情都是自己在默默坚持着，我挺喜欢和别人分享自己的所谓成功，也经常幻想成功之后对着某某云云自己的成功经历，但是现在我什么都不想分享了，什么都不想说了，只想安安静静的做好自己，只想想顺势而为，顺其自然，不追求什么结果，只是在过程中不断调整自己做好自己。加油啊yething，以后要稳重一点了，生活不要慌慌张张，认真生活。</li>\n</ul>\n<h1 id=\"事要悄悄的做，静静的成\"><a href=\"#事要悄悄的做，静静的成\" class=\"headerlink\" title=\"事要悄悄的做，静静的成\"></a>事要悄悄的做，静静的成</h1><ul>\n<li>失败的太多了，反而更像安安静静的做事，做成了再吱声</li>\n</ul>\n<h1 id=\"像下棋一样去走自己的每一步\"><a href=\"#像下棋一样去走自己的每一步\" class=\"headerlink\" title=\"像下棋一样去走自己的每一步\"></a>像下棋一样去走自己的每一步</h1><ul>\n<li>第一人称视角下自己太喜欢随心所欲了，但是自己如果像下棋一样去看待自己甚至周围的人事物会理智许多。</li>\n</ul>\n<h1 id=\"遇事先处理情绪，再解决问题\"><a href=\"#遇事先处理情绪，再解决问题\" class=\"headerlink\" title=\"遇事先处理情绪，再解决问题\"></a>遇事先处理情绪，再解决问题</h1><h1 id=\"千万不要让自己对工具产生依赖\"><a href=\"#千万不要让自己对工具产生依赖\" class=\"headerlink\" title=\"千万不要让自己对工具产生依赖\"></a>千万不要让自己对工具产生依赖</h1><ul>\n<li>自己在工作的时候经常依赖AI开发工具，但是自己很多时候是直接交给AI去干，自己不去研究思考，但是工作中总有意外，为了提高容错率所以自己还是加强自身能力，能研究就研究，能总结就总结，能学习就学习，不仅有碗还得会做饭才行。</li>\n</ul>\n<h1 id=\"要以事情为主，人是事情的一方面，要以做成事情为重\"><a href=\"#要以事情为主，人是事情的一方面，要以做成事情为重\" class=\"headerlink\" title=\"要以事情为主，人是事情的一方面，要以做成事情为重\"></a>要以事情为主，人是事情的一方面，要以做成事情为重</h1><ul>\n<li>要围绕事情展开，处理事情为主，每个人只是事情中的角色，要考虑每个人的角色和做事风格以及利益要害去考虑如何推动事情向自己想要的方向发展。最后我想表达的是，不要以为自己和身边人的情绪化浪费了自己宝贵的时间，多把心思放在如何推送事情发展上，就比如自己当前跟老板对自己是否留任这个事情上面。</li>\n<li>看见自己的两次办的这个社保卡，真是感慨，自己现在已经长大成现在这个样子了，不想过多的为自己感到惋惜，只是更多的希望对得起自己！</li>\n</ul>\n<h1 id=\"无论遇到什么事情都要首先冷静\"><a href=\"#无论遇到什么事情都要首先冷静\" class=\"headerlink\" title=\"无论遇到什么事情都要首先冷静\"></a>无论遇到什么事情都要首先冷静</h1><ul>\n<li>遇到事情不是先把情绪提到首位，而是冷静下来看看如何破局，对战况的思考极其重要，所以要首先冷静下来先把事情处理好，防止后期出现其他措手不及的事情</li>\n<li>遇到问题就去寻找途径解决问题就好了，其他最好不要上来就被情绪拉下水而无法站住脚处理问题，现在才觉得情绪是很弱势的一个东西</li>\n</ul>\n<p>支付6月工资中除21日请假以外的工资    包括我的加班费 工资表<br>你说我是学生才签实训合同，但是我的工作内容和正式员工完全相同，公司是否承认为劳动关系<br>那为何对我进行考勤和业绩考核<br>我同学的公司都给应届生缴纳社保，我们用实训协议是不是就避开了<br>￥￥￥￥￥<br>7月15日支付工资返还合同  工资标准<br>要求公司监督下删除个人文件，留存沟通证据</p>\n<p>合同：<br>    一共两份，第一份是学校给的三方协议（时间是从去年11月份到今年6月份）但是中间今年2月签署离职<br>            第二份是今年四月底自己跟公司做的“实训合同”签署（时间是四月底到6月30）<br>毕业时间：6月30日</p>\n<p>工资组成结构<img src=\"/../images/img-20250704180116480.png\"><br><strong>诉求</strong></p>\n<ol>\n<li>6月工资 公司口头说明是7月15左右发，正常是发4280元，如果我最后被克扣大部分工资后是否可以就不签署劳动合同为由向公司提起仲裁</li>\n<li>公司个人签署知识产权协议，不允许我删除个人电脑信息，是否可以借助法律来删除属于我自己的隐私数据</li>\n<li>因为第二份合同是在毕业之前签订，由工资组成部分是否可以看出是劳动合同然后向税务机关投诉公司避税</li>\n<li>如果后续公司发工资的时候以 我后面这段时间不上班给公司造成损失 为由拒发工资，是否可以仲裁</li>\n</ol>\n<p>辞退对话  公司拒开离职证明<br>证明公司知道我未毕业<br>合同找不到，请出具书面说明确认合同遗失，并承诺补签，如果不能提供主张未签劳动合同的双倍工资<br>今天内。。。 我已尽到告知义务<br>    本人实训协议是否替代劳动合同<br>    公司未缴纳社保是否因为学生身份<br>    辞退不赔偿是不是因为协议约定<br>劳动合同：追讨工资 未签合同双倍工资 </p>\n","categories":["随意"],"tags":["胡言乱语"]},{"title":"我的第一篇博客文章","url":"/posts/2991444807.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><img src=\"/images/file-20241023082318762.png\"></p>\n<p>第一次使用hexo搭建个人博客</p>\n","categories":["随意"]},{"title":"改善驼背","url":"/posts/1791899237.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>以下内容均为GPT生成</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"✅-一、背部肌肉锻炼（增强“拉”的力量，改善含胸）\"><a href=\"#✅-一、背部肌肉锻炼（增强“拉”的力量，改善含胸）\" class=\"headerlink\" title=\"✅ 一、背部肌肉锻炼（增强“拉”的力量，改善含胸）\"></a>✅ <strong>一、背部肌肉锻炼（增强“拉”的力量，改善含胸）</strong></h2><hr>\n<p><img src=\"/../images/img-20250511210906490.png\"></p>\n<h3 id=\"1-俯身飞鸟（Reverse-Fly）\"><a href=\"#1-俯身飞鸟（Reverse-Fly）\" class=\"headerlink\" title=\"1. 俯身飞鸟（Reverse Fly）\"></a>1. <strong>俯身飞鸟（Reverse Fly）</strong></h3><ul>\n<li><p><strong>作用</strong>：锻炼上背部（菱形肌、斜方肌中部），改善肩胛外展、含胸。</p>\n</li>\n<li><p><strong>做法</strong>：</p>\n<ol>\n<li><p>双手持哑铃或水瓶，身体微微前倾，背打直，膝微屈。</p>\n</li>\n<li><p>双手从胸前向两侧张开，类似鸟展翅。</p>\n</li>\n<li><p>手肘微弯，感受肩胛骨收缩。</p>\n</li>\n<li><p>控制节奏慢下慢放。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>次数</strong>：10~15次 / 3组。</p>\n</li>\n<li><p><strong>注意</strong>：不要耸肩；背不要塌。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-引体向上（Pull-Up）\"><a href=\"#2-引体向上（Pull-Up）\" class=\"headerlink\" title=\"2. 引体向上（Pull-Up）\"></a>2. <strong>引体向上（Pull-Up）</strong></h3><ul>\n<li><p><strong>作用</strong>：增强背阔肌、斜方肌，矫正圆肩。</p>\n</li>\n<li><p><strong>做法</strong>：</p>\n<ol>\n<li><p>正握横杠，手略比肩宽。</p>\n</li>\n<li><p>用背部发力拉起，直到下巴越过横杠。</p>\n</li>\n<li><p>缓慢下放身体。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>替代动作</strong>：初学者可用拉力带辅助，或做下拉训练。</p>\n</li>\n<li><p><strong>次数</strong>：力所能及 5~10 次 / 3组。</p>\n</li>\n<li><p><strong>注意</strong>：收肩胛；勿借力甩起。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-超人式（Superman）\"><a href=\"#3-超人式（Superman）\" class=\"headerlink\" title=\"3. 超人式（Superman）\"></a>3. <strong>超人式（Superman）</strong></h3><ul>\n<li><p><strong>作用</strong>：强化腰背部竖脊肌、臀肌，有助改善脊柱稳定性。</p>\n</li>\n<li><p><strong>做法</strong>：</p>\n<ol>\n<li><p>趴在瑜伽垫上，手臂和腿伸直。</p>\n</li>\n<li><p>同时抬起手臂、上胸、双腿，呈”飞行状”。</p>\n</li>\n<li><p>顶点保持1~3秒，慢慢放下。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>次数</strong>：10~15次 / 3组。</p>\n</li>\n<li><p><strong>注意</strong>：避免压脖子，保持颈椎中立。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"4-哑铃划船（Dumbbell-Row）\"><a href=\"#4-哑铃划船（Dumbbell-Row）\" class=\"headerlink\" title=\"4. 哑铃划船（Dumbbell Row）\"></a>4. <strong>哑铃划船（Dumbbell Row）</strong></h3><ul>\n<li><p><strong>作用</strong>：针对中上背部，强化菱形肌和斜方肌。</p>\n</li>\n<li><p><strong>做法</strong>：</p>\n<ol>\n<li><p>俯身90度或一侧扶着凳子，另一手握哑铃。</p>\n</li>\n<li><p>将哑铃朝腰部方向拉起，肘部紧贴身体。</p>\n</li>\n<li><p>控制放下。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>次数</strong>：10~12次 / 每侧3组。</p>\n</li>\n<li><p><strong>注意</strong>：背保持挺直；拉的时候肩胛收缩。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"✅-二、胸肩拉伸（放松“推”的力量，打开胸腔）\"><a href=\"#✅-二、胸肩拉伸（放松“推”的力量，打开胸腔）\" class=\"headerlink\" title=\"✅ 二、胸肩拉伸（放松“推”的力量，打开胸腔）\"></a>✅ <strong>二、胸肩拉伸（放松“推”的力量，打开胸腔）</strong></h2><hr>\n<h3 id=\"5-门框拉伸（Doorway-Stretch）\"><a href=\"#5-门框拉伸（Doorway-Stretch）\" class=\"headerlink\" title=\"5. 门框拉伸（Doorway Stretch）\"></a>5. <strong>门框拉伸（Doorway Stretch）</strong></h3><ul>\n<li><p><strong>作用</strong>：拉伸胸大肌，改善圆肩。</p>\n</li>\n<li><p><strong>做法</strong>：</p>\n<ol>\n<li><p>面对门框，一只手臂弯曲呈90度贴住门框。</p>\n</li>\n<li><p>脚向前跨一步，胸部轻轻前推。</p>\n</li>\n<li><p>感受到胸前拉伸即可。</p>\n</li>\n<li><p>每侧保持20~30秒。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>注意</strong>：不要用力过猛，感觉到胸前轻微拉扯即可。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"6-肩部绕圈运动（Shoulder-Rolls）\"><a href=\"#6-肩部绕圈运动（Shoulder-Rolls）\" class=\"headerlink\" title=\"6. 肩部绕圈运动（Shoulder Rolls）\"></a>6. <strong>肩部绕圈运动（Shoulder Rolls）</strong></h3><ul>\n<li><p><strong>作用</strong>：缓解肩膀僵硬、激活肩带肌群。</p>\n</li>\n<li><p><strong>做法</strong>：</p>\n<ol>\n<li><p>坐或站立，放松双肩。</p>\n</li>\n<li><p>慢慢向后转动肩膀10<del>15圈，然后向前转10</del>15圈。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>次数</strong>：2~3组。</p>\n</li>\n<li><p><strong>注意</strong>：动作不要太快；配合呼吸效果更好。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"7-猫牛式（Cat-Cow-Pose，瑜伽）\"><a href=\"#7-猫牛式（Cat-Cow-Pose，瑜伽）\" class=\"headerlink\" title=\"7. 猫牛式（Cat-Cow Pose，瑜伽）\"></a>7. <strong>猫牛式（Cat-Cow Pose，瑜伽）</strong></h3><ul>\n<li><p><strong>作用</strong>：改善脊柱灵活性，减轻背部僵硬。</p>\n</li>\n<li><p><strong>做法</strong>：</p>\n<ol>\n<li><p>四足跪姿，手掌在肩下，膝盖在髋下。</p>\n</li>\n<li><p>吸气时抬头、塌腰、撅臀（牛式）。</p>\n</li>\n<li><p>呼气时收下巴、拱背、收腹（猫式）。</p>\n</li>\n<li><p>来回缓慢切换，配合呼吸。</p>\n</li>\n</ol>\n</li>\n<li><p><strong>次数</strong>：每组8~10次，练2组。</p>\n</li>\n<li><p><strong>注意</strong>：慢慢做，动作尽量流畅。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"🔁-建议安排（每周-3-5-次）\"><a href=\"#🔁-建议安排（每周-3-5-次）\" class=\"headerlink\" title=\"🔁 建议安排（每周 3~5 次）\"></a>🔁 建议安排（每周 3~5 次）</h2><table>\n<thead>\n<tr>\n<th>类别</th>\n<th>动作</th>\n<th>推荐频率</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>力量训练</td>\n<td>飞鸟、划船、超人、引体</td>\n<td>每周3~4次</td>\n</tr>\n<tr>\n<td>拉伸放松</td>\n<td>门框拉伸、肩部绕圈、猫牛式</td>\n<td>每天1~2次，睡前或久坐后</td>\n</tr>\n</tbody></table>\n<h2 id=\"🧠-总体结构（共约15分钟）：\"><a href=\"#🧠-总体结构（共约15分钟）：\" class=\"headerlink\" title=\"🧠 总体结构（共约15分钟）：\"></a>🧠 总体结构（共约15分钟）：</h2><ol>\n<li><p><strong>热身激活</strong>（2分钟）</p>\n</li>\n<li><p><strong>背部力量训练</strong>（10分钟）</p>\n</li>\n<li><p><strong>胸肩拉伸放松</strong>（3分钟）</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"🔥-1-热身激活（2分钟）\"><a href=\"#🔥-1-热身激活（2分钟）\" class=\"headerlink\" title=\"🔥 1. 热身激活（2分钟）\"></a>🔥 1. 热身激活（2分钟）</h2><ul>\n<li><p><strong>肩部绕圈</strong>：向后20圈，向前20圈（1分钟）</p>\n</li>\n<li><p><strong>动态猫牛式</strong>：慢节奏做10次（1分钟）</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"💪-2-背部力量训练（约10分钟）\"><a href=\"#💪-2-背部力量训练（约10分钟）\" class=\"headerlink\" title=\"💪 2. 背部力量训练（约10分钟）\"></a>💪 2. 背部力量训练（约10分钟）</h2><p>每个动作做 <strong>2组</strong>，中间休息 <strong>30秒</strong>，整组做完再循环一次（共2轮）。</p>\n<table>\n<thead>\n<tr>\n<th>动作</th>\n<th>说明</th>\n<th>次数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>🦅 俯身飞鸟</td>\n<td>双手持哑铃/水瓶，背打直</td>\n<td>12次</td>\n</tr>\n<tr>\n<td>🛶 哑铃划船</td>\n<td>单侧支撑，双臂轮流做</td>\n<td>每侧12次</td>\n</tr>\n<tr>\n<td>🦸 超人式</td>\n<td>趴着抬起四肢</td>\n<td>保持2秒×15次</td>\n</tr>\n<tr>\n<td>🔄 引体向上（或拉力带下拉）</td>\n<td>可用门上引体向上杆辅助</td>\n<td>能做几次做几次</td>\n</tr>\n</tbody></table>\n<p>如没有哑铃，可以用水瓶（装满水的1.5L瓶）代替。</p>\n<hr>\n<h2 id=\"🧘-3-胸肩拉伸放松（3分钟）\"><a href=\"#🧘-3-胸肩拉伸放松（3分钟）\" class=\"headerlink\" title=\"🧘 3. 胸肩拉伸放松（3分钟）\"></a>🧘 3. 胸肩拉伸放松（3分钟）</h2><table>\n<thead>\n<tr>\n<th>动作</th>\n<th>做法</th>\n<th>时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>🚪 门框拉伸</td>\n<td>每侧胸部保持拉伸</td>\n<td>每侧30秒</td>\n</tr>\n<tr>\n<td>🐄🐈 猫牛式</td>\n<td>缓慢配合呼吸</td>\n<td>6~8次</td>\n</tr>\n<tr>\n<td>💨 深呼吸+肩部绕圈</td>\n<td>放松紧张感</td>\n<td>1分钟</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"✅-每周建议频率：\"><a href=\"#✅-每周建议频率：\" class=\"headerlink\" title=\"✅ 每周建议频率：\"></a>✅ 每周建议频率：</h2><ul>\n<li><p><strong>每周至少 4 次</strong>完整训练效果明显</p>\n</li>\n<li><p>坚持 3~4 周后，你会明显感觉背部更挺、肩膀更自然放松。</p>\n</li>\n</ul>\n","categories":["锻炼"],"tags":["锻炼","身体","运动"]},{"title":"排版工具 - Typst","url":"/posts/3498028646.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><strong>放置一些我个人喜欢用的一些工具</strong></p>\n<span id=\"more\"></span>\n<h1 id=\"Typst-平替Latex的新一代工具\"><a href=\"#Typst-平替Latex的新一代工具\" class=\"headerlink\" title=\"Typst 平替Latex的新一代工具\"></a>Typst 平替Latex的新一代工具</h1><hr>\n<ul>\n<li><a href=\"https://typst-doc-cn.github.io/guide/quick-start.html\">中文社区导航</a></li>\n<li><a href=\"https://typst.app/\">官网使用Typst</a></li>\n<li><a href=\"https://typst-doc-cn.github.io/docs/tutorial/writing-in-typst/\">中文教程</a></li>\n<li><a href=\"https://typst.app/docs/\">官网教程-英文</a></li>\n<li><a href=\"https://typst.app/universe/\">https://typst.app/universe/</a></li>\n</ul>\n<blockquote>\n<p>使用方式除了官网编辑器之外，还可以用Vscode安装插件<strong>Tinymistt Typst</strong>进行写作<br>此外Chrome浏览器在浏览Typst官网的时候在地址栏提供下载，可以安装到本地使用。<br>Typst听说是两个德国人被Latex折磨的不行之后自己发明出来的，是优秀的排版工具<br>我是为了写简历才学习使用的，此外还可以用来写论文一类的规范文件。</p>\n</blockquote>\n","categories":["工具"],"tags":["tools"]},{"title":"有关业余时间","url":"/posts/1552263148.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"记录有关人生中对于工作和生活的思考-point1️⃣\"><a href=\"#记录有关人生中对于工作和生活的思考-point1️⃣\" class=\"headerlink\" title=\"记录有关人生中对于工作和生活的思考# point1️⃣\"></a>记录有关人生中对于工作和生活的思考<br><span id=\"more\"></span><br># point1️⃣</h2><p>作为一个软件公司老板和老程序员，我感到这个问题本身是有很大问题的，换句话说，如果能问出这个问题来，思维上的误区和<a href=\"https://zhida.zhihu.com/search?content_id=610240857&amp;content_type=Answer&amp;match_order=1&amp;q=%E6%AD%BB%E4%BA%A1%E8%9E%BA%E6%97%8B&amp;zhida_source=entity\">死亡螺旋</a>就已经快形成了。本质就是用焦虑解决焦虑。</p>\n<p>公司每一批新人到来的时候，我都会告诉他们一个基本的思考方式和一个基础的<a href=\"https://zhida.zhihu.com/search?content_id=610240857&amp;content_type=Answer&amp;match_order=1&amp;q=%E7%A8%8B%E5%BA%8F%E6%80%9D%E7%BB%B4&amp;zhida_source=entity\">程序思维</a>方法，程序思维方式就是要建立静态和动态划分的程序思维，这一点我是觉得应该写入到计算机专业学生入门课程中的思维方式。</p>\n<p>基本的思考方式是我想说的重点，人生的划分的一个基本角度，工作、生活和学习。所有在公司的思考问题的方式都必须按照这三个领域进行划分。每一个领域的道德逻辑和评判标准，社会形成的一般性认知，自身的成长路径都是不同的。既不能割裂，也不能混为一谈。</p>\n<p><strong>工作</strong>这个领域是大学生们毕业后进入公司才真正体会到的一种全新领域，这一领域从入职开始，贯彻始终一直到退休。内容上既有专业建树，也有日常细碎，既有背锅甩锅，也有光荣成就。但是，就我们公司来说，归结到几个核心概念就是。1、这本质上是个痛苦的领域。吃苦是必然的，不存在快乐工作，要么是吃肉体上的苦，要么是吃心理上的苦。也就是，工作不是费力那就是操心。偶尔点缀着一些成就感和价值感而已。2、价值衡量标准就是薪资。长期看，薪资水平取决于<a href=\"https://zhida.zhihu.com/search?content_id=610240857&amp;content_type=Answer&amp;match_order=1&amp;q=%E7%A8%80%E7%BC%BA%E7%A8%8B%E5%BA%A6&amp;zhida_source=entity\">稀缺程度</a>，稀缺程度取决于需求和供给的比例。3、提高工作能力的重点是提交效率，也就是付出的同等的时间，产生更大的工作成果。一般来说<a href=\"https://zhida.zhihu.com/search?content_id=610240857&amp;content_type=Answer&amp;match_order=1&amp;q=%E5%9B%A2%E9%98%9F%E5%8D%8F%E5%90%8C&amp;zhida_source=entity\">团队协同</a>会比单枪匹马的效率更高，但是组织难度非常大。</p>\n<p><strong>生活</strong>这个领域是贯彻人类始终的领域，每个人一出生到死亡，都熟悉这一领域。不管世界怎样改变，生活的本质和特点都不会发生太大的变化。1、生活的目标就是追求幸福，如果生活充满痛苦，那么一个人必须尽快改变生活的方式来调整自己的状态。不存在为了追求幸福而舍弃幸福，要么是伪幸福，要么是违背了生活的本质。2、生活的衡量标准是满足需求过程中，内在的体验的程度，自己鞋子自己穿，舒不舒服自己才知道。必须是不可告人的快乐，而不是在别人面前表演的快乐，即使这种幸福感来自于别人对你的行为。3、生活的重点是不断的满足自己的需求，从简单的肉体到高端的精神等等不一，每个人也是不同的。</p>\n<p><strong>学习</strong>这个领域是人从3岁左右就开始的一种天性，但是很多人会轻易的放弃这一能力领域。1、学习的本质就是自身的成长，如果人停止学习，那么人就会停止成长。2、学习包含身体上的和精神层面上的学习，这两种学习的评价标准并没有什么不同，就是看人有没有在某个领域成长。3、学习的重点就是顺从天性的去做，既要顺从学习这个人类的天性，也要顺从自身特征的天性，也就是找到自己擅长的领域进行学习。另一点就是必须是去做，而不是臆想，幻想一点用没有的。</p>\n<p>基于这样的思维方式，我来回答这个问题，程序员空下来该干什么，既然是空闲下来，说明工作已经完成了，首选肯定是生活领域，追求幸福，享受快乐。不断地满足自己的需求。幸福会让人觉得生命有意义，才能缓解人终归要死亡的本质焦虑。其次是去学习，完成某些方面自身的成长。会使你产生获得感。</p>\n<p>我为什么说思维误区和死亡螺旋，因为很典型，很多人会试图通过工作来使自己感到幸福，这怎么可能，最多能得到暂时的虚荣和逃避焦虑，这种虚假的感觉一过去，会陷入更深层次的焦虑。然后会更加强迫自己去工作。学习也能带来一种满足，但是如果没有解决生活领域的问题，没有解决基础幸福感的问题，也都是一种替代和麻痹。</p>\n<p>除非一种情况，那就是真的能从工作和学习中找到幸福感，这里一定要区分清晰虚荣和幸福，方法也很简单，没有任何人知道，自己也能感到愉快的就是幸福，必须有人知道，自己也能感到愉快的就是虚荣。还要区分<a href=\"https://zhida.zhihu.com/search?content_id=610240857&amp;content_type=Answer&amp;match_order=1&amp;q=%E4%B9%A0%E5%BE%97%E6%84%9F&amp;zhida_source=entity\">习得感</a>和幸福感，非常像，不太好区分，主要的不同就是学习带来的习得感非常自我，是自我获取到的一种体验，而幸福感大都是别人给自己带来的一种体验。</p>\n<p>据我观察，程序员往往不善于和别人交往，生活领域较大缺失，特别容易造成从工作和学习中得到幸福的假象。对于程序员来说，可以说一句矫枉过正的话，只有发生于别人对你所做的行为中，你不可告人的体会到一种快乐，才是真正的幸福。</p>\n<p>空闲下来就去生活，因为人生除了生活幸福之外，没有任何意义，抛弃生活这一领域，不管一个人的工作领域和学习领域多么成功和强大，都会或早或晚的崩溃。</p>\n<p>顺便说一下，找副业是工作领域的事情，说明主业无法获取让自己满足的收入，如果是自身效率低下，是不是自己做了不适合自己的工作，如果效率足够的高，最佳状态是跳槽到更适合自己的岗位。如果要做兼职，这么说吧，兼职往往是低水平的代名词。</p>\n","categories":["思考","反省"],"tags":["工作","生活"]},{"title":"生活大挑战","url":"/posts/2085301975.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>记录自己的最速或者最佳挑战</p>\n<span id=\"more\"></span>\n\n<h1 id=\"2025\"><a href=\"#2025\" class=\"headerlink\" title=\"2025\"></a>2025</h1><h2 id=\"7月份\"><a href=\"#7月份\" class=\"headerlink\" title=\"7月份\"></a>7月份</h2><hr>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 准备明天的会议</li>\n</ul>\n","categories":["计划"],"tags":["挑战"]},{"title":"短期数学总结","url":"/posts/2847308077.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>总结自己短期学习</p>\n<span id=\"more\"></span>\n<h1 id=\"基础系数\"><a href=\"#基础系数\" class=\"headerlink\" title=\"基础系数\"></a>基础系数</h1><ul>\n<li>基础解系定义<ul>\n<li>x=0的解向量（存疑）</li>\n<li>是线性无关的</li>\n<li>线性无关的向量个数 = 自由未知量的个数</li>\n</ul>\n</li>\n<li>基础解系中 含有解向量的个数就是自由未知量的个数</li>\n<li>秩 应该是能够凑成最大nxn的矩阵，如果只有一行或者一列，那么最多只能凑成1x1 ，即秩为1；</li>\n<li>存在基础解系 -&gt; 含有非零解</li>\n<li>不存在基础解系 -&gt; 唯一的解（零解） -&gt; 满秩矩阵</li>\n<li>进行矩阵行列式运算时，左上角不是 <strong>1</strong>就是 <strong>-1</strong></li>\n<li>注意计算认真，此处特别容易丢三落四</li>\n</ul>\n","categories":["高数"],"tags":["数学"]},{"title":"相机那些事","url":"/posts/2087953278.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>收集一些关于Z502的tips</p>\n<span id=\"more\"></span>\n<p><img src=\"/../images/5f0d9be982cb377731b364de81273f3c.png\"><br><img src=\"/../images/a091cd11c2eadb62278fa978ce58573e.png\"><br><img src=\"/../images/8d3fa520858ca03d28150e0ecfee4eb5.png\"><br><img src=\"/../images/037507638b77e82526f715f3dd1b5ac2.png\"><br><img src=\"/../images/b904b50a8e6cf7495483a8a62ccf9ff2.png\"></p>\n<p><img src=\"/../images/b5fdb217ff3f4070bcf463dc6011e898.png\"></p>\n<p><img src=\"/../images/10cbdfcf15b3deddc11e12ecc8f82f67.png\"></p>\n<p><img src=\"/../images/c97b54ccea9a23de48cd34dfc45c6ded.png\"></p>\n<p><img src=\"/../images/7549fd6474a663c7a6db0ecf22ea53f2.png\"></p>\n<p><img src=\"/../images/9deb14d461ac3f1ba3e6c538663109ef.png\"></p>\n<p><img src=\"/../images/7d5772022bd90152fdd8e05eaee41298.png\"></p>\n<p><img src=\"/../images/b27abb44941d26236da588a8af01365f.png\"></p>\n<p><img src=\"/../images/d239827ef231a2f9ef11f30cab095908.png\"></p>\n<p><img src=\"/../images/img-20250529132105544.png\"></p>\n<p><img src=\"/../images/img-20250529132404859.png\"></p>\n<h1 id=\"背带\"><a href=\"#背带\" class=\"headerlink\" title=\"背带\"></a>背带</h1><hr>\n<p><img src=\"/../images/img-20250526080544331.png\"></p>\n","categories":["相机"],"tags":["相机","尼康","Z50II"]},{"title":"网络编程","url":"/posts/4131986683.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><span id=\"more\"></span>\n","categories":["目录"],"tags":["标签"]},{"title":"高等学习笔记","url":"/posts/2782156371.html","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><img src=\"/images/file-20241023100726806.png\"><br><strong>记录高等数学学习过程中的疑惑点</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"二阶线性微分方程\"><a href=\"#二阶线性微分方程\" class=\"headerlink\" title=\"二阶线性微分方程\"></a>二阶线性微分方程</h1><p>二阶线性微分方程是<strong>一类特殊的微分方程，其未知函数及其一阶、二阶导数都是一次方的</strong>。这类方程在数学和物理学中有广泛的应用。以下是对二阶线性微分方程的详细解析：</p>\n<ol>\n<li><strong>基本形式</strong>：二阶线性微分方程的标准形式为y’’+p(x)y’+q(x)y=f(x)，其中p(x), q(x), f(x)在某区间上连续[^1^]。当f(x)=0时，该方程称为齐次方程；当f(x)≠0时，称为非齐次方程[^2^]。</li>\n<li><strong>解的结构</strong>：对于二阶线性微分方程，其解通常包含两个独立的任意常数，这意味着解不是唯一的[^1^]。对于初值问题，如给定初始条件y(x_0)=y_0, y’(x_0)=y_1，则在x_0的邻域内存在唯一的解[^1^]。</li>\n<li><strong>求解方法</strong>：二阶线性微分方程的求解方式分为两类：一是二阶线性齐次微分方程，二是线性非齐次微分方程。齐次方程主要采用特征方程求解，而非齐次方程则在对应的齐次方程的通解上加上特解即为非齐次方程的通解[^2^]。</li>\n<li><strong>特殊类型</strong>：二阶常系数线性微分方程是二阶线性微分方程的一种特殊形式，其中p和q为常数。这种类型的方程在工程技术及力学和物理学中有广泛的应用[^3^]。其求解方法包括待定系数法、多项式法、常数变易法和微分算子法等[^3^]。</li>\n<li><strong>应用实例</strong>：二阶线性微分方程在许多实际问题中都有应用，如振动问题、热传导问题等。例如，简谐振子的位移随时间的变化可以用二阶线性微分方程来描述[^3^]。</li>\n</ol>\n<p>综上所述，二阶线性微分方程不仅是数学理论的重要组成部分，也是解决实际问题的强大工具。通过掌握其基本形式、解的结构、求解方法以及特殊类型，可以更好地理解和应用这一重要的数学概念。</p>\n<hr>\n<p><strong>二阶线性微分方程中的“二阶”指的是微分方程中未知函数的最高导数是二阶导数</strong>。</p>\n<p>二阶导数在数学分析中表示函数变化的加速度，即速度的变化率。在物理问题中，这通常与物体的加速度相关联。例如，在简谐振子模型中，位移随时间的变化可以通过二阶导数来描述，反映了物体受力与其加速度之间的关系[^3^]。</p>\n<p>二阶线性微分方程的标准形式为y’’+p(x)y’+q(x)y=f(x)，其中y’’代表未知函数y关于变量x的二阶导数。这种形式的方程在物理学和工程学中有广泛的应用，如在振动分析、电路理论等领域[^1^][^2^]。</p>\n<hr>\n<p><strong>二阶线性微分方程中的“线性”意味着微分方程中未知函数及其导数都是一次方的</strong>。</p>\n<p>具体来说，这意味着在方程中，未知函数（通常表示为y）和其一阶导数（y’）、二阶导数（y’’）都以一次幂的形式出现。这种形式的方程称为线性微分方程[^1^][^2^]。</p>\n<p>在线性微分方程中，未知函数及其各阶导数作为整体的一次幂，不包含这些变量的高次幂或它们之间的乘积[^2^]。例如，方程y’’+p(x)y’+q(x)y=f(x)中，y、y’和y’’都是一次方的，符合线性的定义[^1^]。</p>\n<p>总的来说，线性特性使得这类微分方程的求解过程具有特定的规律性和简便性，是数学和物理问题中常见的一种形式。</p>\n<h1 id=\"虚数单位-i-的运算公式\"><a href=\"#虚数单位-i-的运算公式\" class=\"headerlink\" title=\"虚数单位 i 的运算公式\"></a>虚数单位 i 的运算公式</h1><hr>\n<p>在数学中，关于虚数单位 ( i ) 的运算公式主要涉及四则运算、幂运算和三角函数等。以下是一些常见的公式：</p>\n<ol>\n<li><p><strong>加法</strong></p>\n<ul>\n<li><strong>公式</strong>：((a + bi) + (c + di) = (a + c) + (b + d)i)</li>\n<li><strong>解释</strong>：虚数相加时，分别将它们的实部和虚部相加[^1^][^2^]。</li>\n</ul>\n</li>\n<li><p><strong>减法</strong></p>\n<ul>\n<li><strong>公式</strong>：((a + bi) - (c + di) = (a - c) + (b - d)i)</li>\n<li><strong>解释</strong>：虚数相减时，分别将它们的实部和虚部相减[^1^][^2^]。</li>\n</ul>\n</li>\n<li><p><strong>乘法</strong></p>\n<ul>\n<li><strong>公式</strong>：((a + bi)(c + di) = ac + (ad + bc)i - bd)</li>\n<li><strong>解释</strong>：利用分配律展开后，再结合 (i^2 = -1) 进行化简[^1^][^2^][^3^]。</li>\n</ul>\n</li>\n<li><p><strong>除法</strong></p>\n<ul>\n<li><strong>公式</strong>：(\\frac{a + bi}{c + di} = \\frac{ac + bd}{c^2 + d^2} + \\frac{bc - ad}{c^2 + d^2}i)</li>\n<li><strong>解释</strong>：首先将分子分母同时乘以分母的共轭复数，使分母变为实数，然后进行除法运算并化简[^1^][^2^][^3^]。</li>\n</ul>\n</li>\n<li><p><strong>幂运算</strong></p>\n<ul>\n<li><strong>公式</strong>：(i^2 = -1)，(i^3 = -i)，(i^4 = 1)，以此类推，形成一个周期为4的循环[^3^][^4^]。</li>\n<li><strong>解释</strong>：虚数单位 (i) 的幂运算具有周期性，每4次幂运算后回到原点。</li>\n</ul>\n</li>\n<li><p><strong>三角函数</strong></p>\n<ul>\n<li><strong>正弦函数</strong>：(\\sin(a + bi) = \\sin(a)\\cos(bi) + \\cos(a)\\sin(bi) = \\sin(a)\\cosh(b) + i\\sinh(b)\\cos(a))</li>\n<li><strong>余弦函数</strong>：(\\cos(a - bi) = \\cos(a)\\cos(bi) + \\sin(a)\\sin(bi) = \\cos(a)\\cosh(b) + i\\sinh(b)\\sin(a))</li>\n<li><strong>正切函数</strong>：(\\tan(a + bi) = \\frac{\\sin(a + bi)}{\\cos(a + bi)})</li>\n<li><strong>余切函数</strong>：(\\cot(a + bi) = \\frac{\\cos(a + bi)}{\\sin(a + bi)})</li>\n<li><strong>正割函数</strong>：(\\sec(a + bi) = \\frac{1}{\\cos(a + bi)})</li>\n<li><strong>余割函数</strong>：(\\csc(a + bi) = \\frac{1}{\\sin(a + bi)})</li>\n<li><strong>解释</strong>：这些三角函数公式将实数域的三角函数扩展到复数域，通过引入双曲函数来处理虚部[^2^][^4^]。</li>\n</ul>\n</li>\n<li><p><strong>复数模和共轭</strong></p>\n<ul>\n<li><strong>模</strong>：对于复数 (a + bi)，其模为 (\\sqrt{a^2 + b^2})。</li>\n<li><strong>共轭</strong>：复数 (a + bi) 的共轭复数为 (a - bi)。</li>\n<li><strong>解释</strong>：模用于表示复数的大小，共轭复数在复数的除法运算中有重要作用。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，这些公式构成了虚数单位 (i) 的基本运算框架，是理解和解决复数问题的基础。</p>\n<h1 id=\"虚数和复数的区别\"><a href=\"#虚数和复数的区别\" class=\"headerlink\" title=\"虚数和复数的区别\"></a>虚数和复数的区别</h1><hr>\n<p>虚数和复数是数学中两个重要的概念，它们在数系中具有不同的地位和作用。下面将详细分析虚数和复数的区别：</p>\n<ol>\n<li><strong>定义与表示</strong><ul>\n<li><strong>虚数</strong>：虚数定义为形如a+bi的数，其中a和b是实数，且b≠0，i² = -1[^3^]。虚数的实部a对应平面上的横轴，虚部b对应纵轴[^5^]。</li>\n<li><strong>复数</strong>：复数通常表示为a+bi的形式，其中a和b都是实数，i为虚数单位[^4^]。复数包括实数和虚数，当b=0时，复数即为实数；当a=0且b≠0时，复数称为纯虚数[^2^]。</li>\n</ul>\n</li>\n<li><strong>历史背景</strong><ul>\n<li><strong>虚数</strong>：虚数的概念由17世纪著名数学家笛卡尔创立，最初被认为是“虚构”的数字，后来发现虚数在解决代数方程中有重要作用[^3^]。</li>\n<li><strong>复数</strong>：复数的历史可以追溯到公元1世纪，希腊数学家海伦首次考虑了复数方根的问题。经过多个世纪的发展，复数逐渐被接受并广泛应用于数学、物理等领域[^4^]。</li>\n</ul>\n</li>\n<li><strong>运算规则</strong><ul>\n<li><strong>虚数</strong>：虚数的加法、乘法等运算遵循特定的规则，例如(a+bi)±(c+di)=(a±c)+(b±d)i，(a+bi)(c+di)=(ac-bd)+(ad+bc)i[^3^]。</li>\n<li><strong>复数</strong>：复数同样有加法、乘法等运算规则，但更为广泛。例如，复数的共轭、模等概念在虚数中并不适用[^4^]。</li>\n</ul>\n</li>\n<li><strong>几何意义</strong><ul>\n<li><strong>虚数</strong>：虚数可以在复平面上表示为点或向量，其实部和虚部分别对应横轴和纵轴[^5^]。</li>\n<li><strong>复数</strong>：复数不仅可以在复平面上表示为点，还可以通过极坐标形式表示，其实部和虚部构成复数的模和幅角[^4^]。</li>\n</ul>\n</li>\n<li><strong>应用领域</strong><ul>\n<li><strong>虚数</strong>：虚数在数学分析、物理学中有广泛应用，特别是在解决某些类型的方程和函数问题时[^1^]。</li>\n<li><strong>复数</strong>：复数的应用更加广泛，涵盖了工程学、信号处理、量子力学等多个领域。复数的理论为许多科学问题的解决提供了基础[^2^]。</li>\n</ul>\n</li>\n<li><strong>哲学意义</strong><ul>\n<li><strong>虚数</strong>：虚数的存在挑战了人们对数字的传统认知，它的引入拓宽了数学的边界[^3^]。</li>\n<li><strong>复数</strong>：复数不仅在数学上有重要地位，还在哲学上引发了对现实世界本质的思考。复数理论的发展促进了对数学抽象思维的理解[^4^]。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，虚数和复数在数学中各自扮演着不可或缺的角色。虚数作为复数的一部分，其独特的性质和应用在数学史上具有重要意义。复数则因其广泛的应用和深刻的理论价值，成为现代数学不可或缺的一部分。</p>\n<p><strong><a href=\"https://zhuanlan.zhihu.com/p/347136244\">虚数与复数与欧拉公式</a></strong></p>\n<h1 id=\"幂指函数求导\"><a href=\"#幂指函数求导\" class=\"headerlink\" title=\"幂指函数求导\"></a>幂指函数求导</h1><hr>\n<p><img src=\"/img-20241027183039392.png\"><br><img src=\"/img-20241027183044860.png\"></p>\n<hr>\n<h1 id=\"余子式与代数余子式\"><a href=\"#余子式与代数余子式\" class=\"headerlink\" title=\"余子式与代数余子式\"></a>余子式与代数余子式</h1><p>余子式和代数余子式在<strong>定义、计算方法以及符号规则</strong>等方面存在区别，下面是详细的对比分析：</p>\n<ol>\n<li><p><strong>定义</strong></p>\n<ul>\n<li><strong>余子式</strong>：余子式是指在n阶行列式中划去元素aij所在的第i行与第j列后，剩下的n-1阶行列式[^1^][^2^]。</li>\n<li><strong>代数余子式</strong>：代数余子式是在余子式的基础上乘以一个特定的符号因子(-1)^(i+j)，即Aij = (-1)^(i+j) * Mij[^3^][^4^]。</li>\n</ul>\n</li>\n<li><p><strong>计算方法</strong></p>\n<ul>\n<li><strong>余子式</strong>：直接计算去掉特定行和列后的行列式。例如，对于5阶行列式，去掉第2行和第4列后得到的3阶行列式即为相应的余子式[^7^]。</li>\n<li><strong>代数余子式</strong>：先计算余子式，然后根据位置添加符号。例如，若某元素的代数余子式为Mi j，则其代数余子式为Aij = (-1)^(i+j) * Mij[^3^]。</li>\n</ul>\n</li>\n<li><p><strong>符号规则</strong></p>\n<ul>\n<li><strong>余子式</strong>：没有特定的符号规则，仅是去掉特定行和列后的行列式。</li>\n<li><strong>代数余子式</strong>：符号由位置决定，(-1)^(i+j)，其中i和j分别是被去掉的行和列的索引[^3^][^4^]。</li>\n</ul>\n</li>\n<li><p><strong>应用</strong></p>\n<ul>\n<li><strong>余子式</strong>：用于简化高阶行列式的计算。通过将高阶行列式转换为低阶行列式，可以更容易地进行数值计算[^5^][^6^]。</li>\n<li><strong>代数余子式</strong>：用于行列式的展开定理，即拉普拉斯展开。行列式等于它的任意一行（或列）的元素与其对应的代数余子式的乘积之和[^8^][^9^]。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"伴随矩阵\"><a href=\"#伴随矩阵\" class=\"headerlink\" title=\"伴随矩阵\"></a>伴随矩阵</h1><p>首先，我们需要明确题目中的符号含义：</p>\n<ul>\n<li>表示矩阵 的行列式。</li>\n<li>表示矩阵 的伴随矩阵（也称为伴随阵或共轭矩阵），其元素是 的代数余子式构成的矩阵的转置。</li>\n<li>是矩阵 的阶数（即矩阵的行数和列数）。</li>\n</ul>\n<p>接下来，我们按照以下步骤来证明 ：</p>\n<p><strong>步骤1：理解伴随矩阵的定义</strong></p>\n<p>伴随矩阵 的元素 是由 去掉第 行和第 列后得到的 阶子矩阵的行列式再乘以 。即：</p>\n<p>其中 是 去掉第 行和第 列后得到的 阶子矩阵。</p>\n<p><strong>步骤2：计算伴随矩阵的行列式</strong></p>\n<p>为了计算 ，我们需要考虑 的每一个元素如何影响最终的行列式值。由于 的每个元素都是 的代数余子式，我们可以利用拉普拉斯定理（也称为按行（列）展开定理）来展开 。</p>\n<p>拉普拉斯定理告诉我们，一个 阶行列式可以表示为它的某一行（或列）的元素与对应的代数余子式乘积之和。对于伴随矩阵 ，其每一行（或列）的元素本身就是 的代数余子式，因此当我们按某一行（或列）展开 时，会得到：</p>\n<p>然而，由于 的构造方式，这里的“代数余子式”实际上就是 的元素（在适当的排列下）。更重要的是，当我们这样展开时，会发现它实际上等于 ，其中 是一个由 的代数余子式构成的 阶矩阵（但这里我们不需要具体计算这个矩阵，因为我们可以直接利用性质简化计算）。</p>\n<p><strong>步骤3：利用行列式的性质简化计算</strong></p>\n<p>根据行列式的性质，特别是行列式的乘法性质（即 ，其中 是常数），我们可以进一步简化计算。注意到，当我们按上述方式展开 时，实际上是在计算一个由 的代数余子式构成的矩阵的行列式，这个矩阵与 有密切的关系。更重要的是，我们可以利用行列式的乘法性质来直接得出结果，而无需具体展开每一个代数余子式。</p>\n<p>具体来说，由于 的每个元素都是 的某个代数余子式乘以 ，因此当我们计算 时，可以将其视为 的某个“修正版”的 次幂（因为每个代数余子式本身就是一个 阶行列式）。通过仔细分析这个“修正版”的构成，我们可以发现它实际上就是 （这里涉及到了较为深入的行列式理论和代数知识，但基于题目的要求，我们可以直接接受这个结论）。</p>\n<p><strong>步骤4：得出结论</strong></p>\n<p>综上所述，我们证明了 。这个结论在矩阵理论和线性代数中有着广泛的应用，特别是在求解矩阵的逆、特征值等问题时。</p>\n<p>需要注意的是，上述证明过程虽然进行了简化和概括，但保留了核心的思想和步骤。在实际教学中，可能需要更详细地展开每一步的推导和计算过程，以便学生更好地理解和掌握这个结论。</p>\n<h1 id=\"曲线的拐点是指曲线凹凸性改变的点\"><a href=\"#曲线的拐点是指曲线凹凸性改变的点\" class=\"headerlink\" title=\"曲线的拐点是指曲线凹凸性改变的点\"></a>曲线的拐点是指曲线凹凸性改变的点</h1><p>判断拐点的存在条件包括必要条件和充分条件。必要条件是函数在该点具有二阶连续导数，且二阶导数为零或不存在。充分条件则是二阶导数在该点的两侧异号，即一侧为正，另一侧为负</p>\n<h1 id=\"一阶导\"><a href=\"#一阶导\" class=\"headerlink\" title=\"一阶导\"></a>一阶导</h1><ul>\n<li>当函数的 <strong>一阶导数大于零时</strong> ，函数在该区间内是单调递增的；</li>\n<li>当函数的 <strong>一阶导数小于零时</strong> ，函数在该区间内是单调递减的。</li>\n</ul>\n<h1 id=\"判断一个函数在某一点是否可导，需要验证该点的导数是否存在\"><a href=\"#判断一个函数在某一点是否可导，需要验证该点的导数是否存在\" class=\"headerlink\" title=\"判断一个函数在某一点是否可导，需要验证该点的导数是否存在\"></a>判断一个函数在某一点是否可导，需要验证该点的导数是否存在</h1><ol>\n<li><strong>连续性</strong> ：首先检查函数在这一点是否连续。如果函数在该点不连续，那么它在这点不可导。</li>\n<li><strong>左右导数</strong> ：计算函数在这一点的左导数和右导数。如果左右导数都存在且相等，则函数在该点可导。</li>\n<li><strong>极限定义法</strong> ：使用导数的极限定义来判断。如果极限 lim⁡h→0f(a+h)−f(a)h<strong>lim</strong>h<strong>→</strong>0*<em><strong>h</strong>f</em>*(<strong>a</strong>+<strong>h</strong>)<strong>−</strong>f**(<strong>a</strong>)**存在且有限，则函数在  <strong>x</strong>=<strong>a</strong> 处可导。</li>\n<li><strong>导数运算法则</strong> ：对于复杂函数，可以利用已知的导数运算法则（如四则运算法则、链式法则等）来计算导数，从而判断其在某点是否可导。</li>\n</ol>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","categories":["数学","高数"],"tags":["数学","高数"]}]